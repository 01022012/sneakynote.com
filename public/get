<!DOCTYPE html>
<html>
  <head>
    <title>SneakyNote.com: Send Secrets Securely</title>
    <link rel="icon" type="image/png" href="/images/padlock-small-square.png" />
    <meta name="robots" content="noindex">
    <style>
      html {
        font-size: 62.5%;
      }
      body {
        margin: 0 auto;
        padding: 0;
        text-align: center;
        width: 500px;
        background-color: #ccc;
        font-size: 1.6em;
        line-height: 1.6;
        font-weight: 300;
        font-family: Helvetica, "HelveticaNeue", "Helvetica Neue", Arial, sans-serif;
        color: #222;
        background-image: url('/images/padlock-small.svg');
        background-attachment: fixed;
      }
      #content {
        background-color: white;
        padding: 20px;
        font-size: 20px;
      }
      h1 {
        margin-top: 0;
        padding: 0;
        font-size: 47px;
        font-family: Futura, Helvetica, "HelveticaNeue", "Helvetica Neue", Arial, sans-serif;
        font-weight: 300;
        letter-spacing: -.18rem;
      }
      h2 {
        font-family: Futura, Helvetica, "HelveticaNeue", "Helvetica Neue", Arial, sans-serif;
        font-weight: 300;
        letter-spacing: -.12rem;
      }
      a {
        color: #1EAEDB;
      }
      a:hover {
        color: #0FA0CE;
      }

      #compromised {
        display: none;
      }
      #expired {
        display: none;
      }
      #compromised h2,
      #badCodeStuff h2 {
        color: #d00;
      }
      #verifyNoteCodeStuff {
        display: none;
      }
      .info {
        font-size: 14px;
        opacity: 0.7;
      }
      .thankYou {
        font-style: italic;
        font-size: 10px;
      }
      #badCodeStuff {
        display: none;
      }
      #noteStuff {
        display: none;
      }
      #padlock {
        height: 26px;
        width: 26px;
        opacity: 0.9;
        vertical-align: text-bottom;
      }
      #noteContent {
        display: inline-block;
        padding: 2px;
        width: 454px;
        height: 400px;
        border: 1px solid gray;
        font-size: 20px;
        margin: 5px 0;
        text-align: left;
        white-space: pre;
        overflow: auto;
      }
      .hidden {
        display: none;
      }
      .highlightBox {
        display: inline-block;
        padding: 8px 14px;
        background: #eee;
        border-radius: 10px;
        font-weight: bold;
      }
      .button,
      button,
      input[type="submit"],
      input[type="reset"],
      input[type="button"] {
        display: inline-block;
        height: 38px;
        padding: 0 30px;
        color: #555;
        text-align: center;
        font-size: 14px;
        font-weight: 600;
        line-height: 38px;
        letter-spacing: .1rem;
        text-transform: uppercase;
        text-decoration: none;
/*        white-space: nowrap;*/
        background-color: rgba(255,255,255,0.8);
        border-radius: 4px;
        border: 1px solid #bbb;
        cursor: pointer;
        box-sizing: border-box; }
      .button:hover,
      button:hover,
      input[type="submit"]:hover,
      input[type="reset"]:hover,
      input[type="button"]:hover,
      .button:focus,
      button:focus,
      input[type="submit"]:focus,
      input[type="reset"]:focus,
      input[type="button"]:focus {
        color: #333;
        border-color: #888;
        outline: 0; }
      .button.button-primary,
      button.button-primary,
      input[type="submit"].button-primary,
      input[type="reset"].button-primary,
      input[type="button"].button-primary {
        color: #FFF;
        background-color: #33C3F0;
        border-color: #33C3F0; }
      .button.button-primary:hover,
      button.button-primary:hover,
      input[type="submit"].button-primary:hover,
      input[type="reset"].button-primary:hover,
      input[type="button"].button-primary:hover,
      .button.button-primary:focus,
      button.button-primary:focus,
      input[type="submit"].button-primary:focus,
      input[type="reset"].button-primary:focus,
      input[type="button"].button-primary:focus {
        color: #FFF;
        background-color: #1EAEDB;
        border-color: #1EAEDB; }
      button {
        font-family: Helvetica, "HelveticaNeue", "Helvetica Neue", Arial, sans-serif;
      }
      button.good,
      button.bad {
        width: 200px;
        height: 100px;
        font-size: 21px;
        margin: 10px;
        padding: 0 10px;
      }
      button.good {
        color: #0a0;
        border-color: #1b1;
        opacity: 0.7;
      }
      button.good:hover {
        opacity: 1.0;
      }
      button.bad {
        color: #d00;
        border-color: #d44;
        opacity: 0.7;
      }
      button.bad:hover {
        opacity: 1.0;
      }
      button#forceShowNote {
        height: 100px;
      }
    </style>
    <script>
      "use strict";

      // Poor man's DOMContentLoaded...
      window.onReadyHandlers = [];

      if(window.location.host.match(/localhost/)) {
        window.sneakyNoteOrigin = window.location.protocol + "//" + window.location.host;
      } else {
        window.sneakyNoteOrigin = "https://sneakynote.com";
      }

      window.hexAlphabet = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];

      // getElementById helper
      function byId(id) {
        return document.getElementById(id);
      }

      function urlKey() {
        return window.location.toString().split("#")[1];
      }

      function uuid() {
        return uuidFromUrlKey(urlKey());
      }

      // Get!
      function get() {
        if (urlKey() === "r9q7wwzsza6tqpcbmmdgmemsz8mp33hm") {
          demo();
        } else {
          getNote(uuid(), get2);
        }
      }
      window.onReadyHandlers.push(get);

      function get2(e) {
        var request = e.target;

        if (request.status === 200) {
          get3(e);
        } else if (request.status === 403) {
          byId("retreiveStatus").innerHTML = "This SneakyNote has already been read!"
          byId("compromised").style.display = "block";
        } else if (request.status === 410) {
          byId("retreiveStatus").innerHTML = "This SneakyNote has expired."
          byId("expired").style.display = "block";
        } else if (request.status === 404) {
          byId("retreiveStatus").innerHTML = "Could not find this SneakyNote. It could be more than one day old."
          byId("compromised").style.display = "block";
        } else {
          byId("retreiveStatus").innerHTML = "An error occured while trying to retreive your SneakyNote."
          byId("compromised").style.display = "block";
        }
      }

      function get3(e) {
        var request = e.target;
        var cipherKey = cipherKeyFromUrlKey(urlKey());
        var iv = ivFromUrlKey(urlKey());

        var plaintextWords;

        try {
          plaintextWords = decrypt(request.response, cipherKey, iv);
        } catch (error) {
          console.log(error);
          byId("retreiveStatus").innerHTML = "An error occurred while decrypting your SneakyNote.";
          byId("compromised").style.display = "block";
          return;
        }

        byId("retreiveStatus").style.display = "none";
        byId("noteCode").innerHTML = request.getResponseHeader("X-Note-Code");
        byId("verifyNoteCodeStuff").style.display = "block";

        var plaintext = sjcl.codec.utf8String.fromBits(plaintextWords);
        byId("noteContent").innerHTML = escapeHtml(plaintext);
      }

      function demo() {
        byId("retreiveStatus").style.display = "none";
        byId("noteContent").innerHTML = "A SneakyNote looks like this when it is opened.\n\nYour secret message will be displayed here.\n\nThis is just a demo message, however.\n\n<a id=\"demoGoBack\" href=\"#back\">Go back</a> or <a href=\"/send\">make a new SneakyNote</a>.";
        byId("noteStuff").style.display = "block";
        byId("demoGoBack").onclick = function (e) {
          window.history.back();
          e.preventDefault();
        };
      }

      function codesMatch() {
        byId("verifyNoteCodeStuff").style.display = "none";
        byId("noteStuff").style.display = "block";
        selectText("noteContent");
      }
      window.onReadyHandlers.push(function () {
        byId("yesTheCodesMatch").onclick = codesMatch;
      });

      function codesDoNotMatch() {
        byId("verifyNoteCodeStuff").style.display = "none";
        byId("badCodeStuff").style.display = "block";
      }
      window.onReadyHandlers.push(function () {
        byId("codesDoNotMatch").onclick = codesDoNotMatch;
      });

      function forceShowNote(e) {
        e.preventDefault();
        byId("badCodeStuff").style.display = "none";
        codesMatch();
      }
      window.onReadyHandlers.push(function () {
        byId("forceShowNote").onclick = forceShowNote;
      });

      function uuidFromUrlKey(urlKey) {
        var uuidWords = sjcl.hash.sha256.hash("uuid" + urlKey);

        var hex = pseudoRandomStringFromBitArray(uuidWords, hexAlphabet, 32)

        hex = hex.substr(0,12) + "4" + hex.substr(13);

        var oddChar = hex[16];

        var newOddChar = {
          "0": "8",
          "1": "9",
          "2": "a",
          "3": "b",
          "4": "8",
          "5": "9",
          "6": "a",
          "7": "b",
          "8": "8",
          "9": "9",
          "a": "a",
          "b": "b",
          "c": "8",
          "d": "9",
          "e": "a",
          "f": "b"
        }[oddChar];

        hex = hex.substr(0,16) + newOddChar + hex.substr(17);

        return hex.substr(0,8) + "-" + hex.substr(8,4) + "-" + hex.substr(12,4) + "-" + hex.substr(16,4) + "-" + hex.substr(20,12);
      }

      // Not a true base conversion, but fine for extracting
      // random strings from pseudorandom data.
      function pseudoRandomStringFromBitArray(bitArray, alphabet, length) {
        var bitsConsumedPerChar = Math.ceil(Math.log(alphabet.length) / Math.log(2))

        var str = ""
        var bitIndex = 0;

        while (str.length < length) {
          var alphabetIndex = sjcl.bitArray.extract(bitArray, bitIndex, bitsConsumedPerChar);
          if (alphabetIndex < alphabet.length) {
            str += alphabet[alphabetIndex]
          }
          bitIndex += bitsConsumedPerChar;
        }

        return str;
      }

      function cipherKeyFromUrlKey(urlKey) {
        return sjcl.hash.sha256.hash("cipherKey" + urlKey);
      }

      function ivFromUrlKey(urlKey) {
        return sjcl.hash.sha256.hash("iv" + urlKey);
      }

      function decrypt(ciphertext, cipherKey, iv) {
        var ciphertextWords = sjcl.codec.arrayBuffer.toBits(ciphertext);
        var aes = new sjcl.cipher.aes(cipherKey);

        return sjcl.mode.ccm.decrypt(aes, ciphertextWords, iv);
      }

      // From mustache.js, MIT license.
      // https://github.com/janl/mustache.js/blob/master/mustache.js
      function escapeHtml (str) {
        var entityMap = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;',
          '/': '&#x2F;'
        };

        return String(str).replace(/[&<>"'\/]/g, function fromEntityMap (s) {
          return entityMap[s];
        });
      }

      function getNote(uuid, callback) {
        var path = "/notes/" + uuid;

        var request = new XMLHttpRequest();
        request.open("GET", path);

        request.onload    = callback;
        request.onerror   = callback;
        request.ontimeout = callback;

        request.responseType = "arraybuffer";
        request.send();
      }
    </script>
    <script>
      // http://stackoverflow.com/questions/985272/selecting-text-in-an-element-akin-to-highlighting-with-your-mouse
      function selectText(elementId) {
        var element = byId(elementId);
        var range, selection;

        // Seems not to work on iOS. Oh well.

        if (document.body.createTextRange) {
          range = document.body.createTextRange();
          range.moveToElementText(element);
          range.select();
        } else if (window.getSelection) {
          selection = window.getSelection();
          range = document.createRange();
          range.selectNodeContents(element);
          selection.removeAllRanges();
          selection.addRange(range);
        }
      }
    </script>
    <script>
      // Excerpts From Stanford Javascript Crypto Library
      // https://bitwiseshiftleft.github.io/sjcl/
      // https://github.com/bitwiseshiftleft/sjcl
      //
      // BSD 2-Clause License
      //
      // Copyright 2009-2010 Emily Stark, Mike Hamburg, Dan Boneh.
      // All rights reserved.
      //
      // Redistribution and use in source and binary forms, with or without
      // modification, are permitted provided that the following conditions are
      // met:
      //
      //    1. Redistributions of source code must retain the above copyright
      //       notice, this list of conditions and the following disclaimer.
      //
      //    2. Redistributions in binary form must reproduce the above
      //       copyright notice, this list of conditions and the following
      //       disclaimer in the documentation and/or other materials provided
      //       with the distribution.
      //
      // THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
      // IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
      // WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
      // DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR CONTRIBUTORS BE
      // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
      // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
      // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
      // BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
      // WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
      // OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
      // IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      //
      // The views and conclusions contained in the software and documentation
      // are those of the authors and should not be interpreted as representing
      // official policies, either expressed or implied, of the authors.




      //////////  core/sjcl.js  //////////

      "use strict";
      /*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */
      /*global document, window, escape, unescape, module, require, Uint32Array */

      /** @namespace The Stanford Javascript Crypto Library, top-level namespace. */
      var sjcl = {
        /** @namespace Symmetric ciphers. */
        cipher: {},

        /** @namespace Hash functions.  Right now only SHA256 is implemented. */
        hash: {},

        /** @namespace Key exchange functions.  Right now only SRP is implemented. */
        keyexchange: {},

        /** @namespace Block cipher modes of operation. */
        mode: {},

        /** @namespace Miscellaneous.  HMAC and PBKDF2. */
        misc: {},

        /**
         * @namespace Bit array encoders and decoders.
         *
         * @description
         * The members of this namespace are functions which translate between
         * SJCL's bitArrays and other objects (usually strings).  Because it
         * isn't always clear which direction is encoding and which is decoding,
         * the method names are "fromBits" and "toBits".
         */
        codec: {},

        /** @namespace Exceptions. */
        exception: {
          /** @constructor Ciphertext is corrupt. */
          corrupt: function(message) {
            this.toString = function() { return "CORRUPT: "+this.message; };
            this.message = message;
          },

          /** @constructor Invalid parameter. */
          invalid: function(message) {
            this.toString = function() { return "INVALID: "+this.message; };
            this.message = message;
          },

          /** @constructor Bug or missing feature in SJCL. @constructor */
          bug: function(message) {
            this.toString = function() { return "BUG: "+this.message; };
            this.message = message;
          },

          /** @constructor Something isn't ready. */
          notReady: function(message) {
            this.toString = function() { return "NOT READY: "+this.message; };
            this.message = message;
          }
        }
      };

      if(typeof module !== 'undefined' && module.exports){
        module.exports = sjcl;
      }
      if (typeof define === "function") {
          define([], function () {
              return sjcl;
          });
      }




      //////////  core/bitArray.js  //////////

      sjcl.bitArray = {
        /**
         * Array slices in units of bits.
         * @param {bitArray} a The array to slice.
         * @param {Number} bstart The offset to the start of the slice, in bits.
         * @param {Number} bend The offset to the end of the slice, in bits.  If this is undefined,
         * slice until the end of the array.
         * @return {bitArray} The requested slice.
         */
        bitSlice: function (a, bstart, bend) {
          a = sjcl.bitArray._shiftRight(a.slice(bstart/32), 32 - (bstart & 31)).slice(1);
          return (bend === undefined) ? a : sjcl.bitArray.clamp(a, bend-bstart);
        },

        /**
         * Extract a number packed into a bit array.
         * @param {bitArray} a The array to slice.
         * @param {Number} bstart The offset to the start of the slice, in bits.
         * @param {Number} length The length of the number to extract.
         * @return {Number} The requested slice.
         */
        extract: function(a, bstart, blength) {
          // FIXME: this Math.floor is not necessary at all, but for some reason
          // seems to suppress a bug in the Chromium JIT.
          var x, sh = Math.floor((-bstart-blength) & 31);
          if ((bstart + blength - 1 ^ bstart) & -32) {
            // it crosses a boundary
            x = (a[bstart/32|0] << (32 - sh)) ^ (a[bstart/32+1|0] >>> sh);
          } else {
            // within a single word
            x = a[bstart/32|0] >>> sh;
          }
          return x & ((1<<blength) - 1);
        },

        /**
         * Concatenate two bit arrays.
         * @param {bitArray} a1 The first array.
         * @param {bitArray} a2 The second array.
         * @return {bitArray} The concatenation of a1 and a2.
         */
        concat: function (a1, a2) {
          if (a1.length === 0 || a2.length === 0) {
            return a1.concat(a2);
          }

          var last = a1[a1.length-1], shift = sjcl.bitArray.getPartial(last);
          if (shift === 32) {
            return a1.concat(a2);
          } else {
            return sjcl.bitArray._shiftRight(a2, shift, last|0, a1.slice(0,a1.length-1));
          }
        },

        /**
         * Find the length of an array of bits.
         * @param {bitArray} a The array.
         * @return {Number} The length of a, in bits.
         */
        bitLength: function (a) {
          var l = a.length, x;
          if (l === 0) { return 0; }
          x = a[l - 1];
          return (l-1) * 32 + sjcl.bitArray.getPartial(x);
        },

        /**
         * Truncate an array.
         * @param {bitArray} a The array.
         * @param {Number} len The length to truncate to, in bits.
         * @return {bitArray} A new array, truncated to len bits.
         */
        clamp: function (a, len) {
          if (a.length * 32 < len) { return a; }
          a = a.slice(0, Math.ceil(len / 32));
          var l = a.length;
          len = len & 31;
          if (l > 0 && len) {
            a[l-1] = sjcl.bitArray.partial(len, a[l-1] & 0x80000000 >> (len-1), 1);
          }
          return a;
        },

        /**
         * Make a partial word for a bit array.
         * @param {Number} len The number of bits in the word.
         * @param {Number} x The bits.
         * @param {Number} [0] _end Pass 1 if x has already been shifted to the high side.
         * @return {Number} The partial word.
         */
        partial: function (len, x, _end) {
          if (len === 32) { return x; }
          return (_end ? x|0 : x << (32-len)) + len * 0x10000000000;
        },

        /**
         * Get the number of bits used by a partial word.
         * @param {Number} x The partial word.
         * @return {Number} The number of bits used by the partial word.
         */
        getPartial: function (x) {
          return Math.round(x/0x10000000000) || 32;
        },

        /**
         * Compare two arrays for equality in a predictable amount of time.
         * @param {bitArray} a The first array.
         * @param {bitArray} b The second array.
         * @return {boolean} true if a == b; false otherwise.
         */
        equal: function (a, b) {
          if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) {
            return false;
          }
          var x = 0, i;
          for (i=0; i<a.length; i++) {
            x |= a[i]^b[i];
          }
          return (x === 0);
        },

        /** Shift an array right.
         * @param {bitArray} a The array to shift.
         * @param {Number} shift The number of bits to shift.
         * @param {Number} [carry=0] A byte to carry in
         * @param {bitArray} [out=[]] An array to prepend to the output.
         * @private
         */
        _shiftRight: function (a, shift, carry, out) {
          var i, last2=0, shift2;
          if (out === undefined) { out = []; }

          for (; shift >= 32; shift -= 32) {
            out.push(carry);
            carry = 0;
          }
          if (shift === 0) {
            return out.concat(a);
          }

          for (i=0; i<a.length; i++) {
            out.push(carry | a[i]>>>shift);
            carry = a[i] << (32-shift);
          }
          last2 = a.length ? a[a.length-1] : 0;
          shift2 = sjcl.bitArray.getPartial(last2);
          out.push(sjcl.bitArray.partial(shift+shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(),1));
          return out;
        },

        /** xor a block of 4 words together.
         * @private
         */
        _xor4: function(x,y) {
          return [x[0]^y[0],x[1]^y[1],x[2]^y[2],x[3]^y[3]];
        },

        /** byteswap a word array inplace.
         * (does not handle partial words)
         * @param {sjcl.bitArray} a word array
         * @return {sjcl.bitArray} byteswapped array
         */
        byteswapM: function(a) {
          var i, v, m = 0xff00;
          for (i = 0; i < a.length; ++i) {
            v = a[i];
            a[i] = (v >>> 24) | ((v >>> 8) & m) | ((v & m) << 8) | (v << 24);
          }
          return a;
        }
      };




      //////////  core/codecArrayBuffer.js  //////////

      //patch arraybuffers if they don't exist
      if (typeof(ArrayBuffer) === 'undefined') {
        (function(globals){
            "use strict";
            globals.ArrayBuffer = function(){};
            globals.DataView = function(){};
        }(this));
      }

      /** @namespace ArrayBuffer */
      sjcl.codec.arrayBuffer = {
        /** Convert from a bitArray to an ArrayBuffer.
         * Will default to 8byte padding if padding is undefined*/
        fromBits: function (arr, padding, padding_count) {
          var out, i, ol, tmp, smallest;
          padding = padding==undefined  ? true : padding
          padding_count = padding_count || 8

          if (arr.length === 0) {
            return new ArrayBuffer(0);
          }

          ol = sjcl.bitArray.bitLength(arr)/8;

          //check to make sure the bitLength is divisible by 8, if it isn't
          //we can't do anything since arraybuffers work with bytes, not bits
          if ( sjcl.bitArray.bitLength(arr)%8 !== 0 ) {
            throw new sjcl.exception.invalid("Invalid bit size, must be divisble by 8 to fit in an arraybuffer correctly")
          }

          if (padding && ol%padding_count !== 0){
            ol += padding_count - (ol%padding_count);
          }


          //padded temp for easy copying
          tmp = new DataView(new ArrayBuffer(arr.length*4));
          for (i=0; i<arr.length; i++) {
            tmp.setUint32(i*4, (arr[i]<<32)); //get rid of the higher bits
          }

          //now copy the final message if we are not going to 0 pad
          out = new DataView(new ArrayBuffer(ol));

          //save a step when the tmp and out bytelength are ===
          if (out.byteLength === tmp.byteLength){
            return tmp.buffer;
          }

          smallest = tmp.byteLength < out.byteLength ? tmp.byteLength : out.byteLength;
          for(i=0; i<smallest; i++){
            out.setUint8(i,tmp.getUint8(i));
          }


          return out.buffer
        },

        toBits: function (buffer) {
          var i, out=[], len, inView, tmp;

          if (buffer.byteLength === 0) {
            return [];
          }

          inView = new DataView(buffer);
          len = inView.byteLength - inView.byteLength%4;

          for (var i = 0; i < len; i+=4) {
            out.push(inView.getUint32(i));
          }

          if (inView.byteLength%4 != 0) {
            tmp = new DataView(new ArrayBuffer(4));
            for (var i = 0, l = inView.byteLength%4; i < l; i++) {
              //we want the data to the right, because partial slices off the starting bits
              tmp.setUint8(i+4-l, inView.getUint8(len+i)); // big-endian,
            }
            out.push(
              sjcl.bitArray.partial( (inView.byteLength%4)*8, tmp.getUint32(0) )
            );
          }
          return out;
        },



        /** Prints a hex output of the buffer contents, akin to hexdump **/
        hexDumpBuffer: function(buffer){
            var stringBufferView = new DataView(buffer)
            var string = ''
            var pad = function (n, width) {
                n = n + '';
                return n.length >= width ? n : new Array(width - n.length + 1).join('0') + n;
            }

            for (var i = 0; i < stringBufferView.byteLength; i+=2) {
                if (i%16 == 0) string += ('\n'+(i).toString(16)+'\t')
                string += ( pad(stringBufferView.getUint16(i).toString(16),4) + ' ')
            }

            if ( typeof console === undefined ){
              console = console || {log:function(){}} //fix for IE
            }
            console.log(string.toUpperCase())
        }
      };




      //////////  core/codecString.js  //////////

      sjcl.codec.utf8String = {
        /** Convert from a bitArray to a UTF-8 string. */
        fromBits: function (arr) {
          var out = "", bl = sjcl.bitArray.bitLength(arr), i, tmp;
          for (i=0; i<bl/8; i++) {
            if ((i&3) === 0) {
              tmp = arr[i/4];
            }
            out += String.fromCharCode(tmp >>> 24);
            tmp <<= 8;
          }
          return decodeURIComponent(escape(out));
        },

        /** Convert from a UTF-8 string to a bitArray. */
        toBits: function (str) {
          str = unescape(encodeURIComponent(str));
          var out = [], i, tmp=0;
          for (i=0; i<str.length; i++) {
            tmp = tmp << 8 | str.charCodeAt(i);
            if ((i&3) === 3) {
              out.push(tmp);
              tmp = 0;
            }
          }
          if (i&3) {
            out.push(sjcl.bitArray.partial(8*(i&3), tmp));
          }
          return out;
        }
      };




      //////////  core/sha256.js  //////////

      /**
       * Context for a SHA-256 operation in progress.
       * @constructor
       * @class Secure Hash Algorithm, 256 bits.
       */
      sjcl.hash.sha256 = function (hash) {
        if (!this._key[0]) { this._precompute(); }
        if (hash) {
          this._h = hash._h.slice(0);
          this._buffer = hash._buffer.slice(0);
          this._length = hash._length;
        } else {
          this.reset();
        }
      };

      /**
       * Hash a string or an array of words.
       * @static
       * @param {bitArray|String} data the data to hash.
       * @return {bitArray} The hash value, an array of 16 big-endian words.
       */
      sjcl.hash.sha256.hash = function (data) {
        return (new sjcl.hash.sha256()).update(data).finalize();
      };

      sjcl.hash.sha256.prototype = {
        /**
         * The hash's block size, in bits.
         * @constant
         */
        blockSize: 512,

        /**
         * Reset the hash state.
         * @return this
         */
        reset:function () {
          this._h = this._init.slice(0);
          this._buffer = [];
          this._length = 0;
          return this;
        },

        /**
         * Input several words to the hash.
         * @param {bitArray|String} data the data to hash.
         * @return this
         */
        update: function (data) {
          if (typeof data === "string") {
            data = sjcl.codec.utf8String.toBits(data);
          }
          var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),
              ol = this._length,
              nl = this._length = ol + sjcl.bitArray.bitLength(data);
          for (i = 512+ol & -512; i <= nl; i+= 512) {
            this._block(b.splice(0,16));
          }
          return this;
        },

        /**
         * Complete hashing and output the hash value.
         * @return {bitArray} The hash value, an array of 8 big-endian words.
         */
        finalize:function () {
          var i, b = this._buffer, h = this._h;

          // Round out and push the buffer
          b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);

          // Round out the buffer to a multiple of 16 words, less the 2 length words.
          for (i = b.length + 2; i & 15; i++) {
            b.push(0);
          }

          // append the length
          b.push(Math.floor(this._length / 0x100000000));
          b.push(this._length | 0);

          while (b.length) {
            this._block(b.splice(0,16));
          }

          this.reset();
          return h;
        },

        /**
         * The SHA-256 initialization vector, to be precomputed.
         * @private
         */
        _init:[],
        /*
        _init:[0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19],
        */

        /**
         * The SHA-256 hash key, to be precomputed.
         * @private
         */
        _key:[],
        /*
        _key:
          [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
           0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
           0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
           0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
           0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
           0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
           0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
           0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2],
        */


        /**
         * Function to precompute _init and _key.
         * @private
         */
        _precompute: function () {
          var i = 0, prime = 2, factor;

          function frac(x) { return (x-Math.floor(x)) * 0x100000000 | 0; }

          outer: for (; i<64; prime++) {
            for (factor=2; factor*factor <= prime; factor++) {
              if (prime % factor === 0) {
                // not a prime
                continue outer;
              }
            }

            if (i<8) {
              this._init[i] = frac(Math.pow(prime, 1/2));
            }
            this._key[i] = frac(Math.pow(prime, 1/3));
            i++;
          }
        },

        /**
         * Perform one cycle of SHA-256.
         * @param {bitArray} words one block of words.
         * @private
         */
        _block:function (words) {
          var i, tmp, a, b,
            w = words.slice(0),
            h = this._h,
            k = this._key,
            h0 = h[0], h1 = h[1], h2 = h[2], h3 = h[3],
            h4 = h[4], h5 = h[5], h6 = h[6], h7 = h[7];

          /* Rationale for placement of |0 :
           * If a value can overflow is original 32 bits by a factor of more than a few
           * million (2^23 ish), there is a possibility that it might overflow the
           * 53-bit mantissa and lose precision.
           *
           * To avoid this, we clamp back to 32 bits by |'ing with 0 on any value that
           * propagates around the loop, and on the hash state h[].  I don't believe
           * that the clamps on h4 and on h0 are strictly necessary, but it's close
           * (for h4 anyway), and better safe than sorry.
           *
           * The clamps on h[] are necessary for the output to be correct even in the
           * common case and for short inputs.
           */
          for (i=0; i<64; i++) {
            // load up the input word for this round
            if (i<16) {
              tmp = w[i];
            } else {
              a   = w[(i+1 ) & 15];
              b   = w[(i+14) & 15];
              tmp = w[i&15] = ((a>>>7  ^ a>>>18 ^ a>>>3  ^ a<<25 ^ a<<14) +
                               (b>>>17 ^ b>>>19 ^ b>>>10 ^ b<<15 ^ b<<13) +
                               w[i&15] + w[(i+9) & 15]) | 0;
            }

            tmp = (tmp + h7 + (h4>>>6 ^ h4>>>11 ^ h4>>>25 ^ h4<<26 ^ h4<<21 ^ h4<<7) +  (h6 ^ h4&(h5^h6)) + k[i]); // | 0;

            // shift register
            h7 = h6; h6 = h5; h5 = h4;
            h4 = h3 + tmp | 0;
            h3 = h2; h2 = h1; h1 = h0;

            h0 = (tmp +  ((h1&h2) ^ (h3&(h1^h2))) + (h1>>>2 ^ h1>>>13 ^ h1>>>22 ^ h1<<30 ^ h1<<19 ^ h1<<10)) | 0;
          }

          h[0] = h[0]+h0 | 0;
          h[1] = h[1]+h1 | 0;
          h[2] = h[2]+h2 | 0;
          h[3] = h[3]+h3 | 0;
          h[4] = h[4]+h4 | 0;
          h[5] = h[5]+h5 | 0;
          h[6] = h[6]+h6 | 0;
          h[7] = h[7]+h7 | 0;
        }
      };




      //////////  core/aes.js  //////////

      sjcl.cipher.aes = function (key) {
        if (!this._tables[0][0][0]) {
          this._precompute();
        }

        var i, j, tmp,
          encKey, decKey,
          sbox = this._tables[0][4], decTable = this._tables[1],
          keyLen = key.length, rcon = 1;

        if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
          throw new sjcl.exception.invalid("invalid aes key size");
        }

        this._key = [encKey = key.slice(0), decKey = []];

        // schedule encryption keys
        for (i = keyLen; i < 4 * keyLen + 28; i++) {
          tmp = encKey[i-1];

          // apply sbox
          if (i%keyLen === 0 || (keyLen === 8 && i%keyLen === 4)) {
            tmp = sbox[tmp>>>24]<<24 ^ sbox[tmp>>16&255]<<16 ^ sbox[tmp>>8&255]<<8 ^ sbox[tmp&255];

            // shift rows and add rcon
            if (i%keyLen === 0) {
              tmp = tmp<<8 ^ tmp>>>24 ^ rcon<<24;
              rcon = rcon<<1 ^ (rcon>>7)*283;
            }
          }

          encKey[i] = encKey[i-keyLen] ^ tmp;
        }

        // schedule decryption keys
        for (j = 0; i; j++, i--) {
          tmp = encKey[j&3 ? i : i - 4];
          if (i<=4 || j<4) {
            decKey[j] = tmp;
          } else {
            decKey[j] = decTable[0][sbox[tmp>>>24      ]] ^
                        decTable[1][sbox[tmp>>16  & 255]] ^
                        decTable[2][sbox[tmp>>8   & 255]] ^
                        decTable[3][sbox[tmp      & 255]];
          }
        }
      };

      sjcl.cipher.aes.prototype = {
        // public
        /* Something like this might appear here eventually
        name: "AES",
        blockSize: 4,
        keySizes: [4,6,8],
        */

        /**
         * Encrypt an array of 4 big-endian words.
         * @param {Array} data The plaintext.
         * @return {Array} The ciphertext.
         */
        encrypt:function (data) { return this._crypt(data,0); },

        /**
         * Decrypt an array of 4 big-endian words.
         * @param {Array} data The ciphertext.
         * @return {Array} The plaintext.
         */
        decrypt:function (data) { return this._crypt(data,1); },

        /**
         * The expanded S-box and inverse S-box tables.  These will be computed
         * on the client so that we don't have to send them down the wire.
         *
         * There are two tables, _tables[0] is for encryption and
         * _tables[1] is for decryption.
         *
         * The first 4 sub-tables are the expanded S-box with MixColumns.  The
         * last (_tables[01][4]) is the S-box itself.
         *
         * @private
         */
        _tables: [[[],[],[],[],[]],[[],[],[],[],[]]],

        /**
         * Expand the S-box tables.
         *
         * @private
         */
        _precompute: function () {
         var encTable = this._tables[0], decTable = this._tables[1],
             sbox = encTable[4], sboxInv = decTable[4],
             i, x, xInv, d=[], th=[], x2, x4, x8, s, tEnc, tDec;

          // Compute double and third tables
         for (i = 0; i < 256; i++) {
           th[( d[i] = i<<1 ^ (i>>7)*283 )^i]=i;
         }

         for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
           // Compute sbox
           s = xInv ^ xInv<<1 ^ xInv<<2 ^ xInv<<3 ^ xInv<<4;
           s = s>>8 ^ s&255 ^ 99;
           sbox[x] = s;
           sboxInv[s] = x;

           // Compute MixColumns
           x8 = d[x4 = d[x2 = d[x]]];
           tDec = x8*0x1010101 ^ x4*0x10001 ^ x2*0x101 ^ x*0x1010100;
           tEnc = d[s]*0x101 ^ s*0x1010100;

           for (i = 0; i < 4; i++) {
             encTable[i][x] = tEnc = tEnc<<24 ^ tEnc>>>8;
             decTable[i][s] = tDec = tDec<<24 ^ tDec>>>8;
           }
         }

         // Compactify.  Considerable speedup on Firefox.
         for (i = 0; i < 5; i++) {
           encTable[i] = encTable[i].slice(0);
           decTable[i] = decTable[i].slice(0);
         }
        },

        /**
         * Encryption and decryption core.
         * @param {Array} input Four words to be encrypted or decrypted.
         * @param dir The direction, 0 for encrypt and 1 for decrypt.
         * @return {Array} The four encrypted or decrypted words.
         * @private
         */
        _crypt:function (input, dir) {
          if (input.length !== 4) {
            throw new sjcl.exception.invalid("invalid aes block size");
          }

          var key = this._key[dir],
              // state variables a,b,c,d are loaded with pre-whitened data
              a = input[0]           ^ key[0],
              b = input[dir ? 3 : 1] ^ key[1],
              c = input[2]           ^ key[2],
              d = input[dir ? 1 : 3] ^ key[3],
              a2, b2, c2,

              nInnerRounds = key.length/4 - 2,
              i,
              kIndex = 4,
              out = [0,0,0,0],
              table = this._tables[dir],

              // load up the tables
              t0    = table[0],
              t1    = table[1],
              t2    = table[2],
              t3    = table[3],
              sbox  = table[4];

          // Inner rounds.  Cribbed from OpenSSL.
          for (i = 0; i < nInnerRounds; i++) {
            a2 = t0[a>>>24] ^ t1[b>>16 & 255] ^ t2[c>>8 & 255] ^ t3[d & 255] ^ key[kIndex];
            b2 = t0[b>>>24] ^ t1[c>>16 & 255] ^ t2[d>>8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];
            c2 = t0[c>>>24] ^ t1[d>>16 & 255] ^ t2[a>>8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];
            d  = t0[d>>>24] ^ t1[a>>16 & 255] ^ t2[b>>8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];
            kIndex += 4;
            a=a2; b=b2; c=c2;
          }

          // Last round.
          for (i = 0; i < 4; i++) {
            out[dir ? 3&-i : i] =
              sbox[a>>>24      ]<<24 ^
              sbox[b>>16  & 255]<<16 ^
              sbox[c>>8   & 255]<<8  ^
              sbox[d      & 255]     ^
              key[kIndex++];
            a2=a; a=b; b=c; c=d; d=a2;
          }

          return out;
        }
      };




      //////////  core/ccm.js  //////////

      sjcl.mode.ccm = {
        /** The name of the mode.
         * @constant
         */
        name: "ccm",

        _progressListeners: [],

        listenProgress: function (cb) {
          sjcl.mode.ccm._progressListeners.push(cb);
        },

        unListenProgress: function (cb) {
          var index = sjcl.mode.ccm._progressListeners.indexOf(cb);
          if (index > -1) {
            sjcl.mode.ccm._progressListeners.splice(index, 1);
          }
        },

        _callProgressListener: function (val) {
          var p = sjcl.mode.ccm._progressListeners.slice(), i;

          for (i = 0; i < p.length; i += 1) {
            p[i](val);
          }
        },

        /** Encrypt in CCM mode.
         * @static
         * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.
         * @param {bitArray} plaintext The plaintext data.
         * @param {bitArray} iv The initialization value.
         * @param {bitArray} [adata=[]] The authenticated data.
         * @param {Number} [tlen=64] the desired tag length, in bits.
         * @return {bitArray} The encrypted data, an array of bytes.
         */
        encrypt: function(prf, plaintext, iv, adata, tlen) {
          var L, out = plaintext.slice(0), tag, w=sjcl.bitArray, ivl = w.bitLength(iv) / 8, ol = w.bitLength(out) / 8;
          tlen = tlen || 64;
          adata = adata || [];

          if (ivl < 7) {
            throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");
          }

          // compute the length of the length
          for (L=2; L<4 && ol >>> 8*L; L++) {}
          if (L < 15 - ivl) { L = 15-ivl; }
          iv = w.clamp(iv,8*(15-L));

          // compute the tag
          tag = sjcl.mode.ccm._computeTag(prf, plaintext, iv, adata, tlen, L);

          // encrypt
          out = sjcl.mode.ccm._ctrMode(prf, out, iv, tag, tlen, L);

          return w.concat(out.data, out.tag);
        },

        /** Decrypt in CCM mode.
         * @static
         * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.
         * @param {bitArray} ciphertext The ciphertext data.
         * @param {bitArray} iv The initialization value.
         * @param {bitArray} [[]] adata The authenticated data.
         * @param {Number} [64] tlen the desired tag length, in bits.
         * @return {bitArray} The decrypted data.
         */
        decrypt: function(prf, ciphertext, iv, adata, tlen) {
          tlen = tlen || 64;
          adata = adata || [];
          var L,
              w=sjcl.bitArray,
              ivl = w.bitLength(iv) / 8,
              ol = w.bitLength(ciphertext),
              out = w.clamp(ciphertext, ol - tlen),
              tag = w.bitSlice(ciphertext, ol - tlen), tag2;


          ol = (ol - tlen) / 8;

          if (ivl < 7) {
            throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");
          }

          // compute the length of the length
          for (L=2; L<4 && ol >>> 8*L; L++) {}
          if (L < 15 - ivl) { L = 15-ivl; }
          iv = w.clamp(iv,8*(15-L));

          // decrypt
          out = sjcl.mode.ccm._ctrMode(prf, out, iv, tag, tlen, L);

          // check the tag
          tag2 = sjcl.mode.ccm._computeTag(prf, out.data, iv, adata, tlen, L);
          if (!w.equal(out.tag, tag2)) {
            throw new sjcl.exception.corrupt("ccm: tag doesn't match");
          }

          return out.data;
        },

        _macAdditionalData: function (prf, adata, iv, tlen, ol, L) {
          var mac, tmp, i, macData = [], w=sjcl.bitArray, xor = w._xor4;

          // mac the flags
          mac = [w.partial(8, (adata.length ? 1<<6 : 0) | (tlen-2) << 2 | L-1)];

          // mac the iv and length
          mac = w.concat(mac, iv);
          mac[3] |= ol;
          mac = prf.encrypt(mac);

          if (adata.length) {
            // mac the associated data.  start with its length...
            tmp = w.bitLength(adata)/8;
            if (tmp <= 0xFEFF) {
              macData = [w.partial(16, tmp)];
            } else if (tmp <= 0xFFFFFFFF) {
              macData = w.concat([w.partial(16,0xFFFE)], [tmp]);
            } // else ...

            // mac the data itself
            macData = w.concat(macData, adata);
            for (i=0; i<macData.length; i += 4) {
              mac = prf.encrypt(xor(mac, macData.slice(i,i+4).concat([0,0,0])));
            }
          }

          return mac;
        },

        /* Compute the (unencrypted) authentication tag, according to the CCM specification
         * @param {Object} prf The pseudorandom function.
         * @param {bitArray} plaintext The plaintext data.
         * @param {bitArray} iv The initialization value.
         * @param {bitArray} adata The authenticated data.
         * @param {Number} tlen the desired tag length, in bits.
         * @return {bitArray} The tag, but not yet encrypted.
         * @private
         */
        _computeTag: function(prf, plaintext, iv, adata, tlen, L) {
          // compute B[0]
          var mac, i, w=sjcl.bitArray, xor = w._xor4;

          tlen /= 8;

          // check tag length and message length
          if (tlen % 2 || tlen < 4 || tlen > 16) {
            throw new sjcl.exception.invalid("ccm: invalid tag length");
          }

          if (adata.length > 0xFFFFFFFF || plaintext.length > 0xFFFFFFFF) {
            // I don't want to deal with extracting high words from doubles.
            throw new sjcl.exception.bug("ccm: can't deal with 4GiB or more data");
          }

          mac = sjcl.mode.ccm._macAdditionalData(prf, adata, iv, tlen, w.bitLength(plaintext)/8, L);

          // mac the plaintext
          for (i=0; i<plaintext.length; i+=4) {
            mac = prf.encrypt(xor(mac, plaintext.slice(i,i+4).concat([0,0,0])));
          }

          return w.clamp(mac, tlen * 8);
        },

        /** CCM CTR mode.
         * Encrypt or decrypt data and tag with the prf in CCM-style CTR mode.
         * May mutate its arguments.
         * @param {Object} prf The PRF.
         * @param {bitArray} data The data to be encrypted or decrypted.
         * @param {bitArray} iv The initialization vector.
         * @param {bitArray} tag The authentication tag.
         * @param {Number} tlen The length of th etag, in bits.
         * @param {Number} L The CCM L value.
         * @return {Object} An object with data and tag, the en/decryption of data and tag values.
         * @private
         */
        _ctrMode: function(prf, data, iv, tag, tlen, L) {
          var enc, i, w=sjcl.bitArray, xor = w._xor4, ctr, l = data.length, bl=w.bitLength(data), n = l/50, p = n;

          // start the ctr
          ctr = w.concat([w.partial(8,L-1)],iv).concat([0,0,0]).slice(0,4);

          // en/decrypt the tag
          tag = w.bitSlice(xor(tag,prf.encrypt(ctr)), 0, tlen);

          // en/decrypt the data
          if (!l) { return {tag:tag, data:[]}; }

          for (i=0; i<l; i+=4) {
            if (i > n) {
              sjcl.mode.ccm._callProgressListener(i/l);
              n += p;
            }
            ctr[3]++;
            enc = prf.encrypt(ctr);
            data[i]   ^= enc[0];
            data[i+1] ^= enc[1];
            data[i+2] ^= enc[2];
            data[i+3] ^= enc[3];
          }
          return { tag:tag, data:w.clamp(data,bl) };
        }
      };

    </script>
  </head>
  <body>
    <div id="content">
      <h1 id="title">Your SneakyNote</h1>

      <div id="retreiveStatus" class="highlightBox">Fetching note...</div>
      <div id="verifyNoteCodeStuff">
        <p>To make sure your note link was not replaced by a bad guy, ask the sender over the telephone if they see this code:*</p>
        <p><span id="noteCode" class="highlightBox"></span></p>
        <p>Do the codes match?</p>
        <div>
          <button id="codesDoNotMatch" class="bad">✘ Codes do not match!</button>
          <button id="yesTheCodesMatch" class="good">✔ Yes, the codes match.</button>
        </div>
        <p class="info">*Verify the code over the telephone or any channel unlikely to be vulnerable to a <a href="http://en.wikipedia.org/wiki/Man-in-the-middle_attack" target="_blank">man-in-the-middle attack</a>. Do not use the same communication method you used to send the secret link.</p>
      </div>
      <div id="badCodeStuff">
        <h2>Consider Secret Compromised</h2>
        <p>
          If the codes do not match, then an attacker has intercepted your original note and sent along their own note instead.
        </p>
        <p>
          Immediately generate and <a href="/send">share</a> a new secret over a different channel!
        </p>
        <p>
          If the codes actually matched and you clicked the wrong button, <a id="forceShowNote" href="#show">click here</a> to see the secret. If the codes did not match you need to take this attack seriously and change the secret.
        </p>
      </div>
      <div id="compromised">
        <h2>Consider Secret Compromised</h2>
        <p>
          SneakyNotes can only be opened once. Can you be sure an attacker has not opened your SneakyNote? Remember, email is not secure.
        </p>
        <p>
          If you and the sender do not know what happened to the original SneakyNote, you should consider your secret compromised.
        </p>
        <p>
          Generate and <a href="/send">share</a> a new secret immediately!
        </p>
      </div>
      <div id="expired">
        <p>
          This SneakyNote was not opened within 10 minutes and has expired without being read. It is no longer available.
        </p>
        <p>
          Ask the sender to send a <a href="/send">new SneakyNote</a>.
        </p>
      </div>
      <div id="noteStuff">
        <p>
          <img src="/images/padlock-small-square.svg" id="padlock"> Here is your secret:
        </p>
        <div id="noteContent"></div>
        <p>
          Your SneakyNote is selected and ready to copy.
        </p>
        <p>
          You are the only one who has seen this page. It cannot be viewed again.
        </p>
        <p class="thankYou">
          Thank you for trusting <a href="/">SneakyNote.com</a> to securely send your secret!
        </p>
      </div>
    </div>
    <script>
      // Poor man's DOMContentLoaded...
      for (i in window.onReadyHandlers) {
        window.onReadyHandlers[i]();
      }
    </script>
  </body>
</html>
