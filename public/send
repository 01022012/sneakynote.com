<!DOCTYPE html>
<html>
  <head>
    <title>Send A SneakyNote - SneakyNote: Send Secrets Securely</title>
    <link rel="icon" type="image/png" href="/images/padlock-small-square.png" sizes="64x64">
    <meta charset="utf-8">
    <meta name="viewport" content="width=500">

    <meta property="og:title" content="Send A SneakyNote">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://sneakynote.com/send">
    <meta property="og:site_name" content="SneakyNote.com">
    <meta property="og:image" content="https://sneakynote.com/images/padlock-small-square-512.png">
    <meta property="og:image:type" content="image/png">
    <meta property="og:image:width" content="512">
    <meta property="og:image:height" content="512">
    <meta property="og:description" content="Compose a SneakyNote here and get a self-destructing, read-once link to share with your friend.">
    <meta name="description" content="Compose a SneakyNote here and get a self-destructing, read-once link to share with your friend.">

    <link rel="apple-touch-icon" type="image/png" href="/images/padlock-small-square-512.png" sizes="512x512">
    <link rel="icon" type="image/png" href="/images/padlock-small-square-512.png" sizes="512x512">

    <style>
      html {
        font-size: 62.5%;
      }
      body {
        margin: 0 auto;
        padding: 0;
        text-align: center;
        width: 500px;
        background-color: #ccc;
        font-size: 1.6em;
        line-height: 1.6;
        font-weight: 300;
        font-family: Helvetica, "HelveticaNeue", "Helvetica Neue", Arial, sans-serif;
        color: #222;
        background-image: url('/images/padlock-small.svg');
        background-attachment: fixed;
      }
      #content {
        background-color: white;
        padding: 20px;
        font-size: 20px;
      }
      h1 {
        margin-top: 0;
        padding: 0;
        font-size: 47px;
        font-family: Futura, Helvetica, "HelveticaNeue", "Helvetica Neue", Arial, sans-serif;
        font-weight: 300;
        letter-spacing: -.18rem;
      }
      a {
        color: #1EAEDB;
      }
      a:hover {
        color: #0FA0CE;
      }
      label, textarea {
        display: inline-block;
      }
      svg {
        fill: currentColor;
      }

      input[type=checkbox] {
        width: 20px;
        height: 20px;
        vertical-align: middle;
      }
      textarea, #sendingStatus {
        padding: 2px;
        width: 454px;
        height: 400px;
        border: 1px solid gray;
        font-size: 20px;
        margin: 5px 0;
        font-weight: 300;
        font-family: Helvetica, "HelveticaNeue", "Helvetica Neue", Arial, sans-serif;
      }
      .obscured {
        text-security: disc;
        -webkit-text-security: disc;
      }
      .hidden {
        display: none;
      }
      .highlightBox {
        display: inline-block;
        padding: 8px 14px;
        background: #eee;
        border-radius: 10px;
        font-weight: bold;
      }
      .button,
      button,
      input[type="submit"],
      input[type="reset"],
      input[type="button"] {
        display: inline-block;
        height: 38px;
        padding: 0 30px;
        color: #555;
        text-align: center;
        font-size: 14px;
        font-weight: 600;
        line-height: 38px;
        letter-spacing: .1rem;
        text-transform: uppercase;
        text-decoration: none;
        white-space: nowrap;
        background-color: rgba(255,255,255,0.8);
        border-radius: 4px;
        border: 1px solid #bbb;
        cursor: pointer;
        box-sizing: border-box; }
      .button:hover,
      button:hover,
      input[type="submit"]:hover,
      input[type="reset"]:hover,
      input[type="button"]:hover,
      .button:focus,
      button:focus,
      input[type="submit"]:focus,
      input[type="reset"]:focus,
      input[type="button"]:focus {
        color: #333;
        border-color: #888;
        outline: 0; }
      .button.button-primary,
      button.button-primary,
      input[type="submit"].button-primary,
      input[type="reset"].button-primary,
      input[type="button"].button-primary {
        color: #FFF;
        background-color: #33C3F0;
        border-color: #33C3F0; }
      .button.button-primary:hover,
      button.button-primary:hover,
      input[type="submit"].button-primary:hover,
      input[type="reset"].button-primary:hover,
      input[type="button"].button-primary:hover,
      .button.button-primary:focus,
      button.button-primary:focus,
      input[type="submit"].button-primary:focus,
      input[type="reset"].button-primary:focus,
      input[type="button"].button-primary:focus {
        color: #FFF;
        background-color: #1EAEDB;
        border-color: #1EAEDB; }
      button {
        width: 460px;
        height: 100px;
        font-size: 34px;
        font-family: Helvetica, "HelveticaNeue", "Helvetica Neue", Arial, sans-serif;
      }
      #sendingStatus {
        position: relative;
      }
      #sendingStatusText {
        margin-top: 41%;
      }

      #randomnessProgress {
        display: inline-block;
        margin-top: 8px;
        width: 200px;
        height: 20px;
        border: 1px solid black;
      }
      #randomnessProgressBar {
        height: 20px;
        background-color: blue;
      }

      #chaseBall {
        height: 100px;
        width: 100px;
        margin: -50px 0 0 -50px;
        border-radius: 50px;
        background-color: green;
        position: absolute;
        color: white;
        line-height: 100px;
      }

      #afterSentStuff {
        display: none;
      }
      #noteStatus {
        line-height: 26px;
      }
      #noteStatusIcon {
        display: inline-block;
        vertical-align: text-bottom;
        width: 26px;
        height: 26px;
        padding: 0 4px 0 0;
        font-size: 32px;
      }
      #noteStatusIcon img {
        width: 26px;
        height: 26px;
        opacity: 0.9;
      }
      #noteStatusText {
        font-weight: bold;
      }
      #noteURL {
        font-size: 13px;
        font-style: italic;
      }
      #noteTimeRemaining {
        font-weight: bold;
      }
      #noteCodeStuff {
        display: none;
      }
      .thankYou {
        font-style: italic;
        font-size: 10px;
      }
      .info {
        font-size: 14px;
        opacity: 0.7;
      }
      #noteExpiredStuff {
        display: none;
      }
    </style>
    <script>
      "use strict";

      // Poor man's DOMContentLoaded...
      window.onReadyHandlers = [];

      if(window.location.host.match(/localhost/)) {
        window.sneakyNoteOrigin = window.location.protocol + "//" + window.location.host;
      } else {
        window.sneakyNoteOrigin = "https://sneakynote.com";
      }

      // 33 chars in base30 is 161.9 bits of entropy.
      window.urlKeyLength = 33;
      // Unambiguous lowercase base30. See https://github.com/brianhempel/base_x#provided-bases for rational.
      window.urlKeyAlphabet = ["2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "j", "k", "m", "n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z"];

      window.hexAlphabet    = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];

      // getElementById helper
      function byId(id) {
        return document.getElementById(id);
      }

      // Send Button
      onReadyHandlers.push(function () {
        byId("sendButton").onclick = function () {
          this.disabled = true;
          send();
        }
      });

      // Send!
      function send() {
        byId("sneakyNoteTextarea").style.display = "none";
        byId("sendingStatus").style.display = "inline-block";

        byId("sendingStatusText").innerHTML = "Gathering Randomness..."
        if (!sjcl.random.isReady()) {
          sjcl.random.addEventListener("seeded", send2);
          byId("sendingStatusText").innerHTML += "touch the ball."
        } else {
          send2();
        }
      }

      function send2() {
        byId("sendingStatusText").innerHTML = "Generating Key..."
        window.urlKey = generateUrlKey();
        window.noteUuid = uuidFromUrlKey(urlKey);
        var cipherKey = cipherKeyFromUrlKey(urlKey)
        var iv = ivFromUrlKey(urlKey)

        byId("sendingStatusText").innerHTML = "Encrypting..."
        var plaintext = byId("sneakyNoteTextarea").value;
        byId("sneakyNoteTextarea").value = "";
        var encrypted = encrypt(plaintext, cipherKey, iv);

        byId("sendingStatusText").innerHTML = "Stashing Your SneakyNote..."
        saveNote(noteUuid, encrypted, send3);
      }

      function send3(e) {
        var request = e.target;

        if (request.status === 201) {
          send4(request)
        } else if (request.status == 413) {
          byId("sendingStatusText").innerHTML = "Your SneakyNote is too large! Can you send something smaller?";
        } else if (request.status == 507) {
          byId("sendingStatusText").innerHTML = "SneakyNote's storage is swamped with other notes right now.<br>Try again later.";
        } else {
          byId("sendingStatusText").innerHTML = "An error occured. :(<br>Try again later.";
        }
      }

      function send4(request) {
        window.noteSentAt = Date.now();

        var url = window.sneakyNoteOrigin + "/get#" + urlKey;

        byId("title").innerHTML = "SneakyNote Ready!";
        byId("noteURL").innerHTML = url;
        byId("mailTo").href = byId("mailTo").href.replace("URLHERE", url);
        byId("beforeSentStuff").style.display = "none";
        byId("afterSentStuff").style.display = "block";
        window.noteCode = request.getResponseHeader("X-Note-Code");
        byId("noteCode").innerHTML = noteCode;
        selectText("noteURL");

        getNoteStatus(window.noteUuid, window.noteCode, updateNoteStatus);
        updateNoteTimeRemaining();
      }

      function updateNoteStatus(e) {
        var request = e.target;

        if (request.status === 200) {
          noteStatusUnopened();
          getNoteStatus(window.noteUuid, window.noteCode, updateNoteStatus);
        } else if (request.status == 403) {
          noteOpened();
        } else if (request.status == 410) {
          noteExpired();
        } else {
          noteStatusError();
          window.setTimeout(function () {
            getNoteStatus(window.noteUuid, window.noteCode, updateNoteStatus);
          }, 5*1000);
        }
      }

      function noteStatusUnopened() {
        byId("noteStatusText").innerHTML = "Unopened";
        byId("noteStatusText").style.color = "inherit";
        byId("noteStatusIcon").innerHTML = '<img src="/images/padlock-small-square.svg">';
        byId("noteStatusIcon").style.color = "inherit";
      }

      function noteOpened() {
        byId("noteStatusText").innerHTML = "Opened";
        byId("noteStatusIcon").innerHTML = '<svg class="icon icon-checkmark" viewBox="0 0 1024 1024"><path class="path1" d="M864 128l-480 480-224-224-160 160 384 384 640-640z"></path></svg>';
        byId("noteStatusIcon").style.color = "#0a0";
        byId("noteURLStuff").style.display = "none";
        byId("noteCodeStuff").style.display = "block";
      }

      function noteExpired() {
        byId("noteStatusText").innerHTML = "Expired";
        byId("noteStatusText").style.color = "#d00";
        byId("noteURLStuff").style.display = "none";
        byId("noteExpiredStuff").style.display = "block";
      }

      function noteStatusError() {
        byId("noteStatusText").innerHTML = "Error Retreiving Note Status!";
        byId("noteStatusText").style.color = "#d00";
        byId("noteStatusIcon").innerHTML = "!!";
        byId("noteStatusIcon").style.color = "#d00";
      }

      function updateNoteTimeRemaining() {
        var expirationTime = window.noteSentAt + (10 * 60 * 1000);
        var msRemaining = expirationTime - Date.now();
        var minutesRemaining = Math.ceil(msRemaining / 1000 / 60);

        if (minutesRemaining == 1) {
          byId("noteTimeRemaining").innerHTML = "1 minute"
        } else {
          byId("noteTimeRemaining").innerHTML = "" + minutesRemaining + " minutes"
        }

        if (minutesRemaining > 0) {
          window.setTimeout(updateNoteTimeRemaining, 500)
        }
      }

      function generateUrlKey() {
        // Way more than we will need.
        var randomWords = sjcl.random.randomWords(50);

        return pseudoRandomStringFromBitArray(randomWords, urlKeyAlphabet, urlKeyLength);
      }

      function uuidFromUrlKey(urlKey) {
        var uuidWords = sjcl.hash.sha256.hash("uuid" + urlKey);

        var hex = pseudoRandomStringFromBitArray(uuidWords, hexAlphabet, 32)

        hex = hex.substr(0,12) + "4" + hex.substr(13);

        var oddChar = hex[16];

        var newOddChar = {
          "0": "8",
          "1": "9",
          "2": "a",
          "3": "b",
          "4": "8",
          "5": "9",
          "6": "a",
          "7": "b",
          "8": "8",
          "9": "9",
          "a": "a",
          "b": "b",
          "c": "8",
          "d": "9",
          "e": "a",
          "f": "b"
        }[oddChar];

        hex = hex.substr(0,16) + newOddChar + hex.substr(17);

        return hex.substr(0,8) + "-" + hex.substr(8,4) + "-" + hex.substr(12,4) + "-" + hex.substr(16,4) + "-" + hex.substr(20,12);
      }

      // Not a true base conversion, but fine for extracting
      // random strings from pseudorandom data.
      function pseudoRandomStringFromBitArray(bitArray, alphabet, length) {
        var bitsConsumedPerChar = Math.ceil(Math.log(alphabet.length) / Math.log(2))

        var str = ""
        var bitIndex = 0;

        while (str.length < length) {
          var alphabetIndex = sjcl.bitArray.extract(bitArray, bitIndex, bitsConsumedPerChar);
          if (alphabetIndex < alphabet.length) {
            str += alphabet[alphabetIndex]
          }
          bitIndex += bitsConsumedPerChar;
        }

        return str;
      }

      function cipherKeyFromUrlKey(urlKey) {
        return sjcl.hash.sha256.hash("cipherKey" + urlKey);
      }

      function ivFromUrlKey(urlKey) {
        return sjcl.hash.sha256.hash("iv" + urlKey);
      }

      function encrypt(plaintext, cipherKey, iv) {
        var plaintextWords = sjcl.codec.utf8String.toBits(plaintext);
        var aes = new sjcl.cipher.aes(cipherKey);

        var cipherTextWords = sjcl.mode.ccm.encrypt(aes, plaintextWords, iv);

        return cipherTextWords;
      }

      function saveNote(uuid, ciphertextWords, callback) {
        var path = "/notes/" + uuid;

        var request = new XMLHttpRequest();
        request.open("POST", path);
        request.setRequestHeader("Content-Type", "application/octet-stream");

        request.onload    = callback;
        request.onerror   = callback;
        request.ontimeout = callback;

        var body = sjcl.codec.arrayBuffer.fromBits(ciphertextWords, 0);
        request.send(body);
      }

      function getNoteStatus(uuid, noteCode, callback) {
        var path = "/notes/" + uuid + "/status";

        var request = new XMLHttpRequest();
        request.open("GET", path);
        request.setRequestHeader("X-Note-Code", noteCode);
        request.setRequestHeader("X-Long-Poll", "true");

        request.onload    = callback;
        request.onerror   = callback;
        request.ontimeout = callback;

        request.send();
      }
    </script>
    <script>
      // http://stackoverflow.com/questions/985272/selecting-text-in-an-element-akin-to-highlighting-with-your-mouse
      function selectText(elementId) {
        var element = byId(elementId);
        var range, selection;

        // Seems not to work on iOS. Oh well.

        if (document.body.createTextRange) {
          range = document.body.createTextRange();
          range.moveToElementText(element);
          range.select();
        } else if (window.getSelection) {
          selection = window.getSelection();
          range = document.createRange();
          range.selectNodeContents(element);
          selection.removeAllRanges();
          selection.addRange(range);
        }
      }
    </script>
    <script>
      // Excerpts From Stanford Javascript Crypto Library
      // https://bitwiseshiftleft.github.io/sjcl/
      // https://github.com/bitwiseshiftleft/sjcl
      //
      // BSD 2-Clause License
      //
      // Copyright 2009-2010 Emily Stark, Mike Hamburg, Dan Boneh.
      // All rights reserved.
      //
      // Redistribution and use in source and binary forms, with or without
      // modification, are permitted provided that the following conditions are
      // met:
      //
      //    1. Redistributions of source code must retain the above copyright
      //       notice, this list of conditions and the following disclaimer.
      //
      //    2. Redistributions in binary form must reproduce the above
      //       copyright notice, this list of conditions and the following
      //       disclaimer in the documentation and/or other materials provided
      //       with the distribution.
      //
      // THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
      // IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
      // WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
      // DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR CONTRIBUTORS BE
      // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
      // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
      // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
      // BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
      // WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
      // OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
      // IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      //
      // The views and conclusions contained in the software and documentation
      // are those of the authors and should not be interpreted as representing
      // official policies, either expressed or implied, of the authors.




      //////////  core/sjcl.js  //////////

      "use strict";
      /*jslint indent: 2, bitwise: false, nomen: false, plusplus: false, white: false, regexp: false */
      /*global document, window, escape, unescape, module, require, Uint32Array */

      /** @namespace The Stanford Javascript Crypto Library, top-level namespace. */
      var sjcl = {
        /** @namespace Symmetric ciphers. */
        cipher: {},

        /** @namespace Hash functions.  Right now only SHA256 is implemented. */
        hash: {},

        /** @namespace Key exchange functions.  Right now only SRP is implemented. */
        keyexchange: {},

        /** @namespace Block cipher modes of operation. */
        mode: {},

        /** @namespace Miscellaneous.  HMAC and PBKDF2. */
        misc: {},

        /**
         * @namespace Bit array encoders and decoders.
         *
         * @description
         * The members of this namespace are functions which translate between
         * SJCL's bitArrays and other objects (usually strings).  Because it
         * isn't always clear which direction is encoding and which is decoding,
         * the method names are "fromBits" and "toBits".
         */
        codec: {},

        /** @namespace Exceptions. */
        exception: {
          /** @constructor Ciphertext is corrupt. */
          corrupt: function(message) {
            this.toString = function() { return "CORRUPT: "+this.message; };
            this.message = message;
          },

          /** @constructor Invalid parameter. */
          invalid: function(message) {
            this.toString = function() { return "INVALID: "+this.message; };
            this.message = message;
          },

          /** @constructor Bug or missing feature in SJCL. @constructor */
          bug: function(message) {
            this.toString = function() { return "BUG: "+this.message; };
            this.message = message;
          },

          /** @constructor Something isn't ready. */
          notReady: function(message) {
            this.toString = function() { return "NOT READY: "+this.message; };
            this.message = message;
          }
        }
      };

      if(typeof module !== 'undefined' && module.exports){
        module.exports = sjcl;
      }
      if (typeof define === "function") {
          define([], function () {
              return sjcl;
          });
      }




      //////////  core/bitArray.js  //////////

      sjcl.bitArray = {
        /**
         * Array slices in units of bits.
         * @param {bitArray} a The array to slice.
         * @param {Number} bstart The offset to the start of the slice, in bits.
         * @param {Number} bend The offset to the end of the slice, in bits.  If this is undefined,
         * slice until the end of the array.
         * @return {bitArray} The requested slice.
         */
        bitSlice: function (a, bstart, bend) {
          a = sjcl.bitArray._shiftRight(a.slice(bstart/32), 32 - (bstart & 31)).slice(1);
          return (bend === undefined) ? a : sjcl.bitArray.clamp(a, bend-bstart);
        },

        /**
         * Extract a number packed into a bit array.
         * @param {bitArray} a The array to slice.
         * @param {Number} bstart The offset to the start of the slice, in bits.
         * @param {Number} length The length of the number to extract.
         * @return {Number} The requested slice.
         */
        extract: function(a, bstart, blength) {
          // FIXME: this Math.floor is not necessary at all, but for some reason
          // seems to suppress a bug in the Chromium JIT.
          var x, sh = Math.floor((-bstart-blength) & 31);
          if ((bstart + blength - 1 ^ bstart) & -32) {
            // it crosses a boundary
            x = (a[bstart/32|0] << (32 - sh)) ^ (a[bstart/32+1|0] >>> sh);
          } else {
            // within a single word
            x = a[bstart/32|0] >>> sh;
          }
          return x & ((1<<blength) - 1);
        },

        /**
         * Concatenate two bit arrays.
         * @param {bitArray} a1 The first array.
         * @param {bitArray} a2 The second array.
         * @return {bitArray} The concatenation of a1 and a2.
         */
        concat: function (a1, a2) {
          if (a1.length === 0 || a2.length === 0) {
            return a1.concat(a2);
          }

          var last = a1[a1.length-1], shift = sjcl.bitArray.getPartial(last);
          if (shift === 32) {
            return a1.concat(a2);
          } else {
            return sjcl.bitArray._shiftRight(a2, shift, last|0, a1.slice(0,a1.length-1));
          }
        },

        /**
         * Find the length of an array of bits.
         * @param {bitArray} a The array.
         * @return {Number} The length of a, in bits.
         */
        bitLength: function (a) {
          var l = a.length, x;
          if (l === 0) { return 0; }
          x = a[l - 1];
          return (l-1) * 32 + sjcl.bitArray.getPartial(x);
        },

        /**
         * Truncate an array.
         * @param {bitArray} a The array.
         * @param {Number} len The length to truncate to, in bits.
         * @return {bitArray} A new array, truncated to len bits.
         */
        clamp: function (a, len) {
          if (a.length * 32 < len) { return a; }
          a = a.slice(0, Math.ceil(len / 32));
          var l = a.length;
          len = len & 31;
          if (l > 0 && len) {
            a[l-1] = sjcl.bitArray.partial(len, a[l-1] & 0x80000000 >> (len-1), 1);
          }
          return a;
        },

        /**
         * Make a partial word for a bit array.
         * @param {Number} len The number of bits in the word.
         * @param {Number} x The bits.
         * @param {Number} [0] _end Pass 1 if x has already been shifted to the high side.
         * @return {Number} The partial word.
         */
        partial: function (len, x, _end) {
          if (len === 32) { return x; }
          return (_end ? x|0 : x << (32-len)) + len * 0x10000000000;
        },

        /**
         * Get the number of bits used by a partial word.
         * @param {Number} x The partial word.
         * @return {Number} The number of bits used by the partial word.
         */
        getPartial: function (x) {
          return Math.round(x/0x10000000000) || 32;
        },

        /**
         * Compare two arrays for equality in a predictable amount of time.
         * @param {bitArray} a The first array.
         * @param {bitArray} b The second array.
         * @return {boolean} true if a == b; false otherwise.
         */
        equal: function (a, b) {
          if (sjcl.bitArray.bitLength(a) !== sjcl.bitArray.bitLength(b)) {
            return false;
          }
          var x = 0, i;
          for (i=0; i<a.length; i++) {
            x |= a[i]^b[i];
          }
          return (x === 0);
        },

        /** Shift an array right.
         * @param {bitArray} a The array to shift.
         * @param {Number} shift The number of bits to shift.
         * @param {Number} [carry=0] A byte to carry in
         * @param {bitArray} [out=[]] An array to prepend to the output.
         * @private
         */
        _shiftRight: function (a, shift, carry, out) {
          var i, last2=0, shift2;
          if (out === undefined) { out = []; }

          for (; shift >= 32; shift -= 32) {
            out.push(carry);
            carry = 0;
          }
          if (shift === 0) {
            return out.concat(a);
          }

          for (i=0; i<a.length; i++) {
            out.push(carry | a[i]>>>shift);
            carry = a[i] << (32-shift);
          }
          last2 = a.length ? a[a.length-1] : 0;
          shift2 = sjcl.bitArray.getPartial(last2);
          out.push(sjcl.bitArray.partial(shift+shift2 & 31, (shift + shift2 > 32) ? carry : out.pop(),1));
          return out;
        },

        /** xor a block of 4 words together.
         * @private
         */
        _xor4: function(x,y) {
          return [x[0]^y[0],x[1]^y[1],x[2]^y[2],x[3]^y[3]];
        },

        /** byteswap a word array inplace.
         * (does not handle partial words)
         * @param {sjcl.bitArray} a word array
         * @return {sjcl.bitArray} byteswapped array
         */
        byteswapM: function(a) {
          var i, v, m = 0xff00;
          for (i = 0; i < a.length; ++i) {
            v = a[i];
            a[i] = (v >>> 24) | ((v >>> 8) & m) | ((v & m) << 8) | (v << 24);
          }
          return a;
        }
      };




      //////////  core/codecArrayBuffer.js  //////////

      //patch arraybuffers if they don't exist
      if (typeof(ArrayBuffer) === 'undefined') {
        (function(globals){
            "use strict";
            globals.ArrayBuffer = function(){};
            globals.DataView = function(){};
        }(this));
      }

      /** @namespace ArrayBuffer */
      sjcl.codec.arrayBuffer = {
        /** Convert from a bitArray to an ArrayBuffer.
         * Will default to 8byte padding if padding is undefined*/
        fromBits: function (arr, padding, padding_count) {
          var out, i, ol, tmp, smallest;
          padding = padding==undefined  ? true : padding
          padding_count = padding_count || 8

          if (arr.length === 0) {
            return new ArrayBuffer(0);
          }

          ol = sjcl.bitArray.bitLength(arr)/8;

          //check to make sure the bitLength is divisible by 8, if it isn't
          //we can't do anything since arraybuffers work with bytes, not bits
          if ( sjcl.bitArray.bitLength(arr)%8 !== 0 ) {
            throw new sjcl.exception.invalid("Invalid bit size, must be divisble by 8 to fit in an arraybuffer correctly")
          }

          if (padding && ol%padding_count !== 0){
            ol += padding_count - (ol%padding_count);
          }


          //padded temp for easy copying
          tmp = new DataView(new ArrayBuffer(arr.length*4));
          for (i=0; i<arr.length; i++) {
            tmp.setUint32(i*4, (arr[i]<<32)); //get rid of the higher bits
          }

          //now copy the final message if we are not going to 0 pad
          out = new DataView(new ArrayBuffer(ol));

          //save a step when the tmp and out bytelength are ===
          if (out.byteLength === tmp.byteLength){
            return tmp.buffer;
          }

          smallest = tmp.byteLength < out.byteLength ? tmp.byteLength : out.byteLength;
          for(i=0; i<smallest; i++){
            out.setUint8(i,tmp.getUint8(i));
          }


          return out.buffer
        },

        toBits: function (buffer) {
          var i, out=[], len, inView, tmp;

          if (buffer.byteLength === 0) {
            return [];
          }

          inView = new DataView(buffer);
          len = inView.byteLength - inView.byteLength%4;

          for (var i = 0; i < len; i+=4) {
            out.push(inView.getUint32(i));
          }

          if (inView.byteLength%4 != 0) {
            tmp = new DataView(new ArrayBuffer(4));
            for (var i = 0, l = inView.byteLength%4; i < l; i++) {
              //we want the data to the right, because partial slices off the starting bits
              tmp.setUint8(i+4-l, inView.getUint8(len+i)); // big-endian,
            }
            out.push(
              sjcl.bitArray.partial( (inView.byteLength%4)*8, tmp.getUint32(0) )
            );
          }
          return out;
        },



        /** Prints a hex output of the buffer contents, akin to hexdump **/
        hexDumpBuffer: function(buffer){
            var stringBufferView = new DataView(buffer)
            var string = ''
            var pad = function (n, width) {
                n = n + '';
                return n.length >= width ? n : new Array(width - n.length + 1).join('0') + n;
            }

            for (var i = 0; i < stringBufferView.byteLength; i+=2) {
                if (i%16 == 0) string += ('\n'+(i).toString(16)+'\t')
                string += ( pad(stringBufferView.getUint16(i).toString(16),4) + ' ')
            }

            if ( typeof console === undefined ){
              console = console || {log:function(){}} //fix for IE
            }
            console.log(string.toUpperCase())
        }
      };




      //////////  core/codecString.js  //////////

      sjcl.codec.utf8String = {
        /** Convert from a bitArray to a UTF-8 string. */
        fromBits: function (arr) {
          var out = "", bl = sjcl.bitArray.bitLength(arr), i, tmp;
          for (i=0; i<bl/8; i++) {
            if ((i&3) === 0) {
              tmp = arr[i/4];
            }
            out += String.fromCharCode(tmp >>> 24);
            tmp <<= 8;
          }
          return decodeURIComponent(escape(out));
        },

        /** Convert from a UTF-8 string to a bitArray. */
        toBits: function (str) {
          str = unescape(encodeURIComponent(str));
          var out = [], i, tmp=0;
          for (i=0; i<str.length; i++) {
            tmp = tmp << 8 | str.charCodeAt(i);
            if ((i&3) === 3) {
              out.push(tmp);
              tmp = 0;
            }
          }
          if (i&3) {
            out.push(sjcl.bitArray.partial(8*(i&3), tmp));
          }
          return out;
        }
      };




      //////////  core/sha256.js  //////////

      /**
       * Context for a SHA-256 operation in progress.
       * @constructor
       * @class Secure Hash Algorithm, 256 bits.
       */
      sjcl.hash.sha256 = function (hash) {
        if (!this._key[0]) { this._precompute(); }
        if (hash) {
          this._h = hash._h.slice(0);
          this._buffer = hash._buffer.slice(0);
          this._length = hash._length;
        } else {
          this.reset();
        }
      };

      /**
       * Hash a string or an array of words.
       * @static
       * @param {bitArray|String} data the data to hash.
       * @return {bitArray} The hash value, an array of 16 big-endian words.
       */
      sjcl.hash.sha256.hash = function (data) {
        return (new sjcl.hash.sha256()).update(data).finalize();
      };

      sjcl.hash.sha256.prototype = {
        /**
         * The hash's block size, in bits.
         * @constant
         */
        blockSize: 512,

        /**
         * Reset the hash state.
         * @return this
         */
        reset:function () {
          this._h = this._init.slice(0);
          this._buffer = [];
          this._length = 0;
          return this;
        },

        /**
         * Input several words to the hash.
         * @param {bitArray|String} data the data to hash.
         * @return this
         */
        update: function (data) {
          if (typeof data === "string") {
            data = sjcl.codec.utf8String.toBits(data);
          }
          var i, b = this._buffer = sjcl.bitArray.concat(this._buffer, data),
              ol = this._length,
              nl = this._length = ol + sjcl.bitArray.bitLength(data);
          for (i = 512+ol & -512; i <= nl; i+= 512) {
            this._block(b.splice(0,16));
          }
          return this;
        },

        /**
         * Complete hashing and output the hash value.
         * @return {bitArray} The hash value, an array of 8 big-endian words.
         */
        finalize:function () {
          var i, b = this._buffer, h = this._h;

          // Round out and push the buffer
          b = sjcl.bitArray.concat(b, [sjcl.bitArray.partial(1,1)]);

          // Round out the buffer to a multiple of 16 words, less the 2 length words.
          for (i = b.length + 2; i & 15; i++) {
            b.push(0);
          }

          // append the length
          b.push(Math.floor(this._length / 0x100000000));
          b.push(this._length | 0);

          while (b.length) {
            this._block(b.splice(0,16));
          }

          this.reset();
          return h;
        },

        /**
         * The SHA-256 initialization vector, to be precomputed.
         * @private
         */
        _init:[],
        /*
        _init:[0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19],
        */

        /**
         * The SHA-256 hash key, to be precomputed.
         * @private
         */
        _key:[],
        /*
        _key:
          [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
           0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
           0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
           0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
           0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
           0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
           0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
           0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2],
        */


        /**
         * Function to precompute _init and _key.
         * @private
         */
        _precompute: function () {
          var i = 0, prime = 2, factor;

          function frac(x) { return (x-Math.floor(x)) * 0x100000000 | 0; }

          outer: for (; i<64; prime++) {
            for (factor=2; factor*factor <= prime; factor++) {
              if (prime % factor === 0) {
                // not a prime
                continue outer;
              }
            }

            if (i<8) {
              this._init[i] = frac(Math.pow(prime, 1/2));
            }
            this._key[i] = frac(Math.pow(prime, 1/3));
            i++;
          }
        },

        /**
         * Perform one cycle of SHA-256.
         * @param {bitArray} words one block of words.
         * @private
         */
        _block:function (words) {
          var i, tmp, a, b,
            w = words.slice(0),
            h = this._h,
            k = this._key,
            h0 = h[0], h1 = h[1], h2 = h[2], h3 = h[3],
            h4 = h[4], h5 = h[5], h6 = h[6], h7 = h[7];

          /* Rationale for placement of |0 :
           * If a value can overflow is original 32 bits by a factor of more than a few
           * million (2^23 ish), there is a possibility that it might overflow the
           * 53-bit mantissa and lose precision.
           *
           * To avoid this, we clamp back to 32 bits by |'ing with 0 on any value that
           * propagates around the loop, and on the hash state h[].  I don't believe
           * that the clamps on h4 and on h0 are strictly necessary, but it's close
           * (for h4 anyway), and better safe than sorry.
           *
           * The clamps on h[] are necessary for the output to be correct even in the
           * common case and for short inputs.
           */
          for (i=0; i<64; i++) {
            // load up the input word for this round
            if (i<16) {
              tmp = w[i];
            } else {
              a   = w[(i+1 ) & 15];
              b   = w[(i+14) & 15];
              tmp = w[i&15] = ((a>>>7  ^ a>>>18 ^ a>>>3  ^ a<<25 ^ a<<14) +
                               (b>>>17 ^ b>>>19 ^ b>>>10 ^ b<<15 ^ b<<13) +
                               w[i&15] + w[(i+9) & 15]) | 0;
            }

            tmp = (tmp + h7 + (h4>>>6 ^ h4>>>11 ^ h4>>>25 ^ h4<<26 ^ h4<<21 ^ h4<<7) +  (h6 ^ h4&(h5^h6)) + k[i]); // | 0;

            // shift register
            h7 = h6; h6 = h5; h5 = h4;
            h4 = h3 + tmp | 0;
            h3 = h2; h2 = h1; h1 = h0;

            h0 = (tmp +  ((h1&h2) ^ (h3&(h1^h2))) + (h1>>>2 ^ h1>>>13 ^ h1>>>22 ^ h1<<30 ^ h1<<19 ^ h1<<10)) | 0;
          }

          h[0] = h[0]+h0 | 0;
          h[1] = h[1]+h1 | 0;
          h[2] = h[2]+h2 | 0;
          h[3] = h[3]+h3 | 0;
          h[4] = h[4]+h4 | 0;
          h[5] = h[5]+h5 | 0;
          h[6] = h[6]+h6 | 0;
          h[7] = h[7]+h7 | 0;
        }
      };




      //////////  core/aes.js  //////////

      sjcl.cipher.aes = function (key) {
        if (!this._tables[0][0][0]) {
          this._precompute();
        }

        var i, j, tmp,
          encKey, decKey,
          sbox = this._tables[0][4], decTable = this._tables[1],
          keyLen = key.length, rcon = 1;

        if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
          throw new sjcl.exception.invalid("invalid aes key size");
        }

        this._key = [encKey = key.slice(0), decKey = []];

        // schedule encryption keys
        for (i = keyLen; i < 4 * keyLen + 28; i++) {
          tmp = encKey[i-1];

          // apply sbox
          if (i%keyLen === 0 || (keyLen === 8 && i%keyLen === 4)) {
            tmp = sbox[tmp>>>24]<<24 ^ sbox[tmp>>16&255]<<16 ^ sbox[tmp>>8&255]<<8 ^ sbox[tmp&255];

            // shift rows and add rcon
            if (i%keyLen === 0) {
              tmp = tmp<<8 ^ tmp>>>24 ^ rcon<<24;
              rcon = rcon<<1 ^ (rcon>>7)*283;
            }
          }

          encKey[i] = encKey[i-keyLen] ^ tmp;
        }

        // schedule decryption keys
        for (j = 0; i; j++, i--) {
          tmp = encKey[j&3 ? i : i - 4];
          if (i<=4 || j<4) {
            decKey[j] = tmp;
          } else {
            decKey[j] = decTable[0][sbox[tmp>>>24      ]] ^
                        decTable[1][sbox[tmp>>16  & 255]] ^
                        decTable[2][sbox[tmp>>8   & 255]] ^
                        decTable[3][sbox[tmp      & 255]];
          }
        }
      };

      sjcl.cipher.aes.prototype = {
        // public
        /* Something like this might appear here eventually
        name: "AES",
        blockSize: 4,
        keySizes: [4,6,8],
        */

        /**
         * Encrypt an array of 4 big-endian words.
         * @param {Array} data The plaintext.
         * @return {Array} The ciphertext.
         */
        encrypt:function (data) { return this._crypt(data,0); },

        /**
         * Decrypt an array of 4 big-endian words.
         * @param {Array} data The ciphertext.
         * @return {Array} The plaintext.
         */
        decrypt:function (data) { return this._crypt(data,1); },

        /**
         * The expanded S-box and inverse S-box tables.  These will be computed
         * on the client so that we don't have to send them down the wire.
         *
         * There are two tables, _tables[0] is for encryption and
         * _tables[1] is for decryption.
         *
         * The first 4 sub-tables are the expanded S-box with MixColumns.  The
         * last (_tables[01][4]) is the S-box itself.
         *
         * @private
         */
        _tables: [[[],[],[],[],[]],[[],[],[],[],[]]],

        /**
         * Expand the S-box tables.
         *
         * @private
         */
        _precompute: function () {
         var encTable = this._tables[0], decTable = this._tables[1],
             sbox = encTable[4], sboxInv = decTable[4],
             i, x, xInv, d=[], th=[], x2, x4, x8, s, tEnc, tDec;

          // Compute double and third tables
         for (i = 0; i < 256; i++) {
           th[( d[i] = i<<1 ^ (i>>7)*283 )^i]=i;
         }

         for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
           // Compute sbox
           s = xInv ^ xInv<<1 ^ xInv<<2 ^ xInv<<3 ^ xInv<<4;
           s = s>>8 ^ s&255 ^ 99;
           sbox[x] = s;
           sboxInv[s] = x;

           // Compute MixColumns
           x8 = d[x4 = d[x2 = d[x]]];
           tDec = x8*0x1010101 ^ x4*0x10001 ^ x2*0x101 ^ x*0x1010100;
           tEnc = d[s]*0x101 ^ s*0x1010100;

           for (i = 0; i < 4; i++) {
             encTable[i][x] = tEnc = tEnc<<24 ^ tEnc>>>8;
             decTable[i][s] = tDec = tDec<<24 ^ tDec>>>8;
           }
         }

         // Compactify.  Considerable speedup on Firefox.
         for (i = 0; i < 5; i++) {
           encTable[i] = encTable[i].slice(0);
           decTable[i] = decTable[i].slice(0);
         }
        },

        /**
         * Encryption and decryption core.
         * @param {Array} input Four words to be encrypted or decrypted.
         * @param dir The direction, 0 for encrypt and 1 for decrypt.
         * @return {Array} The four encrypted or decrypted words.
         * @private
         */
        _crypt:function (input, dir) {
          if (input.length !== 4) {
            throw new sjcl.exception.invalid("invalid aes block size");
          }

          var key = this._key[dir],
              // state variables a,b,c,d are loaded with pre-whitened data
              a = input[0]           ^ key[0],
              b = input[dir ? 3 : 1] ^ key[1],
              c = input[2]           ^ key[2],
              d = input[dir ? 1 : 3] ^ key[3],
              a2, b2, c2,

              nInnerRounds = key.length/4 - 2,
              i,
              kIndex = 4,
              out = [0,0,0,0],
              table = this._tables[dir],

              // load up the tables
              t0    = table[0],
              t1    = table[1],
              t2    = table[2],
              t3    = table[3],
              sbox  = table[4];

          // Inner rounds.  Cribbed from OpenSSL.
          for (i = 0; i < nInnerRounds; i++) {
            a2 = t0[a>>>24] ^ t1[b>>16 & 255] ^ t2[c>>8 & 255] ^ t3[d & 255] ^ key[kIndex];
            b2 = t0[b>>>24] ^ t1[c>>16 & 255] ^ t2[d>>8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];
            c2 = t0[c>>>24] ^ t1[d>>16 & 255] ^ t2[a>>8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];
            d  = t0[d>>>24] ^ t1[a>>16 & 255] ^ t2[b>>8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];
            kIndex += 4;
            a=a2; b=b2; c=c2;
          }

          // Last round.
          for (i = 0; i < 4; i++) {
            out[dir ? 3&-i : i] =
              sbox[a>>>24      ]<<24 ^
              sbox[b>>16  & 255]<<16 ^
              sbox[c>>8   & 255]<<8  ^
              sbox[d      & 255]     ^
              key[kIndex++];
            a2=a; a=b; b=c; c=d; d=a2;
          }

          return out;
        }
      };




      //////////  core/ccm.js  //////////

      sjcl.mode.ccm = {
        /** The name of the mode.
         * @constant
         */
        name: "ccm",

        _progressListeners: [],

        listenProgress: function (cb) {
          sjcl.mode.ccm._progressListeners.push(cb);
        },

        unListenProgress: function (cb) {
          var index = sjcl.mode.ccm._progressListeners.indexOf(cb);
          if (index > -1) {
            sjcl.mode.ccm._progressListeners.splice(index, 1);
          }
        },

        _callProgressListener: function (val) {
          var p = sjcl.mode.ccm._progressListeners.slice(), i;

          for (i = 0; i < p.length; i += 1) {
            p[i](val);
          }
        },

        /** Encrypt in CCM mode.
         * @static
         * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.
         * @param {bitArray} plaintext The plaintext data.
         * @param {bitArray} iv The initialization value.
         * @param {bitArray} [adata=[]] The authenticated data.
         * @param {Number} [tlen=64] the desired tag length, in bits.
         * @return {bitArray} The encrypted data, an array of bytes.
         */
        encrypt: function(prf, plaintext, iv, adata, tlen) {
          var L, out = plaintext.slice(0), tag, w=sjcl.bitArray, ivl = w.bitLength(iv) / 8, ol = w.bitLength(out) / 8;
          tlen = tlen || 64;
          adata = adata || [];

          if (ivl < 7) {
            throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");
          }

          // compute the length of the length
          for (L=2; L<4 && ol >>> 8*L; L++) {}
          if (L < 15 - ivl) { L = 15-ivl; }
          iv = w.clamp(iv,8*(15-L));

          // compute the tag
          tag = sjcl.mode.ccm._computeTag(prf, plaintext, iv, adata, tlen, L);

          // encrypt
          out = sjcl.mode.ccm._ctrMode(prf, out, iv, tag, tlen, L);

          return w.concat(out.data, out.tag);
        },

        /** Decrypt in CCM mode.
         * @static
         * @param {Object} prf The pseudorandom function.  It must have a block size of 16 bytes.
         * @param {bitArray} ciphertext The ciphertext data.
         * @param {bitArray} iv The initialization value.
         * @param {bitArray} [[]] adata The authenticated data.
         * @param {Number} [64] tlen the desired tag length, in bits.
         * @return {bitArray} The decrypted data.
         */
        decrypt: function(prf, ciphertext, iv, adata, tlen) {
          tlen = tlen || 64;
          adata = adata || [];
          var L,
              w=sjcl.bitArray,
              ivl = w.bitLength(iv) / 8,
              ol = w.bitLength(ciphertext),
              out = w.clamp(ciphertext, ol - tlen),
              tag = w.bitSlice(ciphertext, ol - tlen), tag2;


          ol = (ol - tlen) / 8;

          if (ivl < 7) {
            throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");
          }

          // compute the length of the length
          for (L=2; L<4 && ol >>> 8*L; L++) {}
          if (L < 15 - ivl) { L = 15-ivl; }
          iv = w.clamp(iv,8*(15-L));

          // decrypt
          out = sjcl.mode.ccm._ctrMode(prf, out, iv, tag, tlen, L);

          // check the tag
          tag2 = sjcl.mode.ccm._computeTag(prf, out.data, iv, adata, tlen, L);
          if (!w.equal(out.tag, tag2)) {
            throw new sjcl.exception.corrupt("ccm: tag doesn't match");
          }

          return out.data;
        },

        _macAdditionalData: function (prf, adata, iv, tlen, ol, L) {
          var mac, tmp, i, macData = [], w=sjcl.bitArray, xor = w._xor4;

          // mac the flags
          mac = [w.partial(8, (adata.length ? 1<<6 : 0) | (tlen-2) << 2 | L-1)];

          // mac the iv and length
          mac = w.concat(mac, iv);
          mac[3] |= ol;
          mac = prf.encrypt(mac);

          if (adata.length) {
            // mac the associated data.  start with its length...
            tmp = w.bitLength(adata)/8;
            if (tmp <= 0xFEFF) {
              macData = [w.partial(16, tmp)];
            } else if (tmp <= 0xFFFFFFFF) {
              macData = w.concat([w.partial(16,0xFFFE)], [tmp]);
            } // else ...

            // mac the data itself
            macData = w.concat(macData, adata);
            for (i=0; i<macData.length; i += 4) {
              mac = prf.encrypt(xor(mac, macData.slice(i,i+4).concat([0,0,0])));
            }
          }

          return mac;
        },

        /* Compute the (unencrypted) authentication tag, according to the CCM specification
         * @param {Object} prf The pseudorandom function.
         * @param {bitArray} plaintext The plaintext data.
         * @param {bitArray} iv The initialization value.
         * @param {bitArray} adata The authenticated data.
         * @param {Number} tlen the desired tag length, in bits.
         * @return {bitArray} The tag, but not yet encrypted.
         * @private
         */
        _computeTag: function(prf, plaintext, iv, adata, tlen, L) {
          // compute B[0]
          var mac, i, w=sjcl.bitArray, xor = w._xor4;

          tlen /= 8;

          // check tag length and message length
          if (tlen % 2 || tlen < 4 || tlen > 16) {
            throw new sjcl.exception.invalid("ccm: invalid tag length");
          }

          if (adata.length > 0xFFFFFFFF || plaintext.length > 0xFFFFFFFF) {
            // I don't want to deal with extracting high words from doubles.
            throw new sjcl.exception.bug("ccm: can't deal with 4GiB or more data");
          }

          mac = sjcl.mode.ccm._macAdditionalData(prf, adata, iv, tlen, w.bitLength(plaintext)/8, L);

          // mac the plaintext
          for (i=0; i<plaintext.length; i+=4) {
            mac = prf.encrypt(xor(mac, plaintext.slice(i,i+4).concat([0,0,0])));
          }

          return w.clamp(mac, tlen * 8);
        },

        /** CCM CTR mode.
         * Encrypt or decrypt data and tag with the prf in CCM-style CTR mode.
         * May mutate its arguments.
         * @param {Object} prf The PRF.
         * @param {bitArray} data The data to be encrypted or decrypted.
         * @param {bitArray} iv The initialization vector.
         * @param {bitArray} tag The authentication tag.
         * @param {Number} tlen The length of th etag, in bits.
         * @param {Number} L The CCM L value.
         * @return {Object} An object with data and tag, the en/decryption of data and tag values.
         * @private
         */
        _ctrMode: function(prf, data, iv, tag, tlen, L) {
          var enc, i, w=sjcl.bitArray, xor = w._xor4, ctr, l = data.length, bl=w.bitLength(data), n = l/50, p = n;

          // start the ctr
          ctr = w.concat([w.partial(8,L-1)],iv).concat([0,0,0]).slice(0,4);

          // en/decrypt the tag
          tag = w.bitSlice(xor(tag,prf.encrypt(ctr)), 0, tlen);

          // en/decrypt the data
          if (!l) { return {tag:tag, data:[]}; }

          for (i=0; i<l; i+=4) {
            if (i > n) {
              sjcl.mode.ccm._callProgressListener(i/l);
              n += p;
            }
            ctr[3]++;
            enc = prf.encrypt(ctr);
            data[i]   ^= enc[0];
            data[i+1] ^= enc[1];
            data[i+2] ^= enc[2];
            data[i+3] ^= enc[3];
          }
          return { tag:tag, data:w.clamp(data,bl) };
        }
      };



      //////////  core/random.js (Fortuna/SHA256 w/entropy estimation)  ////////

      sjcl.prng = function(defaultParanoia) {

        /* private */
        this._pools                   = [new sjcl.hash.sha256()];
        this._poolEntropy             = [0];
        this._reseedCount             = 0;
        this._robins                  = {};
        this._eventId                 = 0;

        this._collectorIds            = {};
        this._collectorIdNext         = 0;

        this._strength                = 0;
        this._poolStrength            = 0;
        this._nextReseed              = 0;
        this._key                     = [0,0,0,0,0,0,0,0];
        this._counter                 = [0,0,0,0];
        this._cipher                  = undefined;
        this._defaultParanoia         = defaultParanoia;

        /* event listener stuff */
        this._collectorsStarted       = false;
        this._callbacks               = {progress: {}, seeded: {}};
        this._callbackI               = 0;

        /* constants */
        this._NOT_READY               = 0;
        this._READY                   = 1;
        this._REQUIRES_RESEED         = 2;

        this._MAX_WORDS_PER_BURST     = 65536;
        this._PARANOIA_LEVELS         = [0,48,64,96,128,192,256,384,512,768,1024];
        this._MILLISECONDS_PER_RESEED = 30000;
        this._BITS_PER_RESEED         = 80;
      };

      sjcl.prng.prototype = {
        /** Generate several random words, and return them in an array.
         * A word consists of 32 bits (4 bytes)
         * @param {Number} nwords The number of words to generate.
         */
        randomWords: function (nwords, paranoia) {
          var out = [], i, readiness = this.isReady(paranoia), g;

          if (readiness === this._NOT_READY) {
            throw new sjcl.exception.notReady("generator isn't seeded");
          } else if (readiness & this._REQUIRES_RESEED) {
            this._reseedFromPools(!(readiness & this._READY));
          }

          for (i=0; i<nwords; i+= 4) {
            if ((i+1) % this._MAX_WORDS_PER_BURST === 0) {
              this._gate();
            }

            g = this._gen4words();
            out.push(g[0],g[1],g[2],g[3]);
          }
          this._gate();

          return out.slice(0,nwords);
        },

        setDefaultParanoia: function (paranoia, allowZeroParanoia) {
          if (paranoia === 0 && allowZeroParanoia !== "Setting paranoia=0 will ruin your security; use it only for testing") {
            throw "Setting paranoia=0 will ruin your security; use it only for testing";
          }

          this._defaultParanoia = paranoia;
        },

        /**
         * Add entropy to the pools.
         * @param data The entropic value.  Should be a 32-bit integer, array of 32-bit integers, or string
         * @param {Number} estimatedEntropy The estimated entropy of data, in bits
         * @param {String} source The source of the entropy, eg "mouse"
         */
        addEntropy: function (data, estimatedEntropy, source) {
          source = source || "user";

          var id,
            i, tmp,
            t = (new Date()).valueOf(),
            robin = this._robins[source],
            oldReady = this.isReady(), err = 0, objName;

          id = this._collectorIds[source];
          if (id === undefined) { id = this._collectorIds[source] = this._collectorIdNext ++; }

          if (robin === undefined) { robin = this._robins[source] = 0; }
          this._robins[source] = ( this._robins[source] + 1 ) % this._pools.length;

          switch(typeof(data)) {

          case "number":
            if (estimatedEntropy === undefined) {
              estimatedEntropy = 1;
            }
            this._pools[robin].update([id,this._eventId++,1,estimatedEntropy,t,1,data|0]);
            break;

          case "object":
            objName = Object.prototype.toString.call(data);
            if (objName === "[object Uint32Array]") {
              tmp = [];
              for (i = 0; i < data.length; i++) {
                tmp.push(data[i]);
              }
              data = tmp;
            } else {
              if (objName !== "[object Array]") {
                err = 1;
              }
              for (i=0; i<data.length && !err; i++) {
                if (typeof(data[i]) !== "number") {
                  err = 1;
                }
              }
            }
            if (!err) {
              if (estimatedEntropy === undefined) {
                /* horrible entropy estimator */
                estimatedEntropy = 0;
                for (i=0; i<data.length; i++) {
                  tmp= data[i];
                  while (tmp>0) {
                    estimatedEntropy++;
                    tmp = tmp >>> 1;
                  }
                }
              }
              this._pools[robin].update([id,this._eventId++,2,estimatedEntropy,t,data.length].concat(data));
            }
            break;

          case "string":
            if (estimatedEntropy === undefined) {
             /* English text has just over 1 bit per character of entropy.
              * But this might be HTML or something, and have far less
              * entropy than English...  Oh well, let's just say one bit.
              */
             estimatedEntropy = data.length;
            }
            this._pools[robin].update([id,this._eventId++,3,estimatedEntropy,t,data.length]);
            this._pools[robin].update(data);
            break;

          default:
            err=1;
          }
          if (err) {
            throw new sjcl.exception.bug("random: addEntropy only supports number, array of numbers or string");
          }

          /* record the new strength */
          this._poolEntropy[robin] += estimatedEntropy;
          this._poolStrength += estimatedEntropy;

          /* fire off events */
          if (oldReady === this._NOT_READY) {
            if (this.isReady() !== this._NOT_READY) {
              this._fireEvent("seeded", Math.max(this._strength, this._poolStrength));
            }
            this._fireEvent("progress", this.getProgress());
          }
        },

        /** Is the generator ready? */
        isReady: function (paranoia) {
          var entropyRequired = this._PARANOIA_LEVELS[ (paranoia !== undefined) ? paranoia : this._defaultParanoia ];

          if (this._strength && this._strength >= entropyRequired) {
            return (this._poolEntropy[0] > this._BITS_PER_RESEED && (new Date()).valueOf() > this._nextReseed) ?
              this._REQUIRES_RESEED | this._READY :
              this._READY;
          } else {
            return (this._poolStrength >= entropyRequired) ?
              this._REQUIRES_RESEED | this._NOT_READY :
              this._NOT_READY;
          }
        },

        /** Get the generator's progress toward readiness, as a fraction */
        getProgress: function (paranoia) {
          var entropyRequired = this._PARANOIA_LEVELS[ paranoia ? paranoia : this._defaultParanoia ];

          if (this._strength >= entropyRequired) {
            return 1.0;
          } else {
            return (this._poolStrength > entropyRequired) ?
              1.0 :
              this._poolStrength / entropyRequired;
          }
        },

        /** start the built-in entropy collectors */
        startCollectors: function () {
          if (this._collectorsStarted) { return; }

          this._eventListener = {
            loadTimeCollector: this._bind(this._loadTimeCollector),
            mouseCollector: this._bind(this._mouseCollector),
            keyboardCollector: this._bind(this._keyboardCollector),
            accelerometerCollector: this._bind(this._accelerometerCollector),
            touchCollector: this._bind(this._touchCollector)
          };

          if (window.addEventListener) {
            window.addEventListener("load", this._eventListener.loadTimeCollector, false);
            window.addEventListener("mousemove", this._eventListener.mouseCollector, false);
            window.addEventListener("keypress", this._eventListener.keyboardCollector, false);
            window.addEventListener("devicemotion", this._eventListener.accelerometerCollector, false);
            window.addEventListener("touchmove", this._eventListener.touchCollector, false);
          } else if (document.attachEvent) {
            document.attachEvent("onload", this._eventListener.loadTimeCollector);
            document.attachEvent("onmousemove", this._eventListener.mouseCollector);
            document.attachEvent("keypress", this._eventListener.keyboardCollector);
          } else {
            throw new sjcl.exception.bug("can't attach event");
          }

          this._collectorsStarted = true;
        },

        /** stop the built-in entropy collectors */
        stopCollectors: function () {
          if (!this._collectorsStarted) { return; }

          if (window.removeEventListener) {
            window.removeEventListener("load", this._eventListener.loadTimeCollector, false);
            window.removeEventListener("mousemove", this._eventListener.mouseCollector, false);
            window.removeEventListener("keypress", this._eventListener.keyboardCollector, false);
            window.removeEventListener("devicemotion", this._eventListener.accelerometerCollector, false);
            window.removeEventListener("touchmove", this._eventListener.touchCollector, false);
          } else if (document.detachEvent) {
            document.detachEvent("onload", this._eventListener.loadTimeCollector);
            document.detachEvent("onmousemove", this._eventListener.mouseCollector);
            document.detachEvent("keypress", this._eventListener.keyboardCollector);
          }

          this._collectorsStarted = false;
        },

        /* use a cookie to store entropy.
        useCookie: function (all_cookies) {
            throw new sjcl.exception.bug("random: useCookie is unimplemented");
        },*/

        /** add an event listener for progress or seeded-ness. */
        addEventListener: function (name, callback) {
          this._callbacks[name][this._callbackI++] = callback;
        },

        /** remove an event listener for progress or seeded-ness */
        removeEventListener: function (name, cb) {
          var i, j, cbs=this._callbacks[name], jsTemp=[];

          /* I'm not sure if this is necessary; in C++, iterating over a
           * collection and modifying it at the same time is a no-no.
           */

          for (j in cbs) {
            if (cbs.hasOwnProperty(j) && cbs[j] === cb) {
              jsTemp.push(j);
            }
          }

          for (i=0; i<jsTemp.length; i++) {
            j = jsTemp[i];
            delete cbs[j];
          }
        },

        _bind: function (func) {
          var that = this;
          return function () {
            func.apply(that, arguments);
          };
        },

        /** Generate 4 random words, no reseed, no gate.
         * @private
         */
        _gen4words: function () {
          for (var i=0; i<4; i++) {
            this._counter[i] = this._counter[i]+1 | 0;
            if (this._counter[i]) { break; }
          }
          return this._cipher.encrypt(this._counter);
        },

        /* Rekey the AES instance with itself after a request, or every _MAX_WORDS_PER_BURST words.
         * @private
         */
        _gate: function () {
          this._key = this._gen4words().concat(this._gen4words());
          this._cipher = new sjcl.cipher.aes(this._key);
        },

        /** Reseed the generator with the given words
         * @private
         */
        _reseed: function (seedWords) {
          this._key = sjcl.hash.sha256.hash(this._key.concat(seedWords));
          this._cipher = new sjcl.cipher.aes(this._key);
          for (var i=0; i<4; i++) {
            this._counter[i] = this._counter[i]+1 | 0;
            if (this._counter[i]) { break; }
          }
        },

        /** reseed the data from the entropy pools
         * @param full If set, use all the entropy pools in the reseed.
         */
        _reseedFromPools: function (full) {
          var reseedData = [], strength = 0, i;

          this._nextReseed = reseedData[0] =
            (new Date()).valueOf() + this._MILLISECONDS_PER_RESEED;

          for (i=0; i<16; i++) {
            /* On some browsers, this is cryptographically random.  So we might
             * as well toss it in the pot and stir...
             */
            reseedData.push(Math.random()*0x100000000|0);
          }

          for (i=0; i<this._pools.length; i++) {
           reseedData = reseedData.concat(this._pools[i].finalize());
           strength += this._poolEntropy[i];
           this._poolEntropy[i] = 0;

           if (!full && (this._reseedCount & (1<<i))) { break; }
          }

          /* if we used the last pool, push a new one onto the stack */
          if (this._reseedCount >= 1 << this._pools.length) {
           this._pools.push(new sjcl.hash.sha256());
           this._poolEntropy.push(0);
          }

          /* how strong was this reseed? */
          this._poolStrength -= strength;
          if (strength > this._strength) {
            this._strength = strength;
          }

          this._reseedCount ++;
          this._reseed(reseedData);
        },

        _keyboardCollector: function () {
          this._addCurrentTimeToEntropy(1);
        },

        _mouseCollector: function (ev) {
          var x, y;

          try {
            x = ev.x || ev.clientX || ev.offsetX || 0;
            y = ev.y || ev.clientY || ev.offsetY || 0;
          } catch (err) {
            // Event originated from a secure element. No mouse position available.
            x = 0;
            y = 0;
          }

          if (x != 0 && y!= 0) {
            sjcl.random.addEntropy([x,y], 2, "mouse");
          }

          this._addCurrentTimeToEntropy(0);
        },

        _touchCollector: function(ev) {
          var touch = ev.touches[0] || ev.changedTouches[0];
          var x = touch.pageX || touch.clientX,
              y = touch.pageY || touch.clientY;

          sjcl.random.addEntropy([x,y],1,"touch");

          this._addCurrentTimeToEntropy(0);
        },

        _loadTimeCollector: function () {
          this._addCurrentTimeToEntropy(2);
        },

        _addCurrentTimeToEntropy: function (estimatedEntropy) {
          if (typeof window !== 'undefined' && window.performance && typeof window.performance.now === "function") {
            //how much entropy do we want to add here?
            sjcl.random.addEntropy(window.performance.now(), estimatedEntropy, "loadtime");
          } else {
            sjcl.random.addEntropy((new Date()).valueOf(), estimatedEntropy, "loadtime");
          }
        },
        _accelerometerCollector: function (ev) {
          var ac = ev.accelerationIncludingGravity.x||ev.accelerationIncludingGravity.y||ev.accelerationIncludingGravity.z;
          if(window.orientation){
            var or = window.orientation;
            if (typeof or === "number") {
              sjcl.random.addEntropy(or, 1, "accelerometer");
            }
          }
          if (ac) {
            sjcl.random.addEntropy(ac, 2, "accelerometer");
          }
          this._addCurrentTimeToEntropy(0);
        },

        _fireEvent: function (name, arg) {
          var j, cbs=sjcl.random._callbacks[name], cbsTemp=[];
          /* TODO: there is a race condition between removing collectors and firing them */

          /* I'm not sure if this is necessary; in C++, iterating over a
           * collection and modifying it at the same time is a no-no.
           */

          for (j in cbs) {
            if (cbs.hasOwnProperty(j)) {
              cbsTemp.push(cbs[j]);
            }
          }

          for (j=0; j<cbsTemp.length; j++) {
            cbsTemp[j](arg);
          }
        }
      };

      /** an instance for the prng.
      * @see sjcl.prng
      */
      sjcl.random = new sjcl.prng(6);

      (function(){
        // function for getting nodejs crypto module. catches and ignores errors.
        function getCryptoModule() {
          try {
            return require('crypto');
          }
          catch (e) {
            return null;
          }
        }

        try {
          var buf, crypt, ab;

          // get cryptographically strong entropy depending on runtime environment
          if (typeof module !== 'undefined' && module.exports && (crypt = getCryptoModule()) && crypt.randomBytes) {
            buf = crypt.randomBytes(1024/8);
            buf = new Uint32Array(new Uint8Array(buf).buffer);
            sjcl.random.addEntropy(buf, 1024, "crypto.randomBytes");

          } else if (typeof window !== 'undefined' && typeof Uint32Array !== 'undefined') {
            ab = new Uint32Array(32);
            if (window.crypto && window.crypto.getRandomValues) {
              window.crypto.getRandomValues(ab);
            } else if (window.msCrypto && window.msCrypto.getRandomValues) {
              window.msCrypto.getRandomValues(ab);
            } else {
              return;
            }

            // get cryptographically strong entropy in Webkit
            sjcl.random.addEntropy(ab, 1024, "crypto.getRandomValues");

          } else {
            // no getRandomValues :-(
          }
        } catch (e) {
          if (typeof window !== 'undefined' && window.console) {
            console.log("There was an error collecting entropy from the browser:");
            console.log(e);
            //we do not want the library to fail due to randomness not being maintained.
          }
        }
      }());
    </script>
    <script>
      // 256 bits. We only need ~160bits.
      sjcl.random.setDefaultParanoia(6);
    </script>
  </head>
  <body>
    <div id="content">
      <h1 id="title">Send a SneakyNote</h1>

      <div id="beforeSentStuff">
        <p>Compose your note in the box below.</p>
        <script>
          // Only show the "Show Text" checkbox if we are on Webkit...
          if(('textSecurity' in document.body.style) || ('webkitTextSecurity' in document.body.style)) {
            document.write('<label id="showTextControl"><input type="checkbox" id="showTextCheckbox">Show Text</label>');

            window.onReadyHandlers.push(function() {
                byId('showTextCheckbox').onchange = function () {
                  if (this.checked) {
                    byId("sneakyNoteTextarea").className = ""
                  } else {
                    byId("sneakyNoteTextarea").className = "obscured"
                  }
                  byId("sneakyNoteTextarea").focus();
                };
            });
          }
        </script>
        <textarea id="sneakyNoteTextarea" class="obscured" autofocus></textarea>
        <div id="sendingStatus" class="hidden">
          <div id="sendingStatusText"></div>
          <div id="randomnessProgress">
            <div id="randomnessProgressBar"></div>
          </div>
          <div id="chaseBall">Hit Me</div>
        </div>
        <button id="sendButton" class="button-primary">Send Securely</button>
      </div>
      <div id="afterSentStuff">
        <p>Note Status: <span id="noteStatus" class="highlightBox"><span id="noteStatusIcon"><img src="/images/padlock-small-square.svg"></span><span id="noteStatusText">Unopened</span></span></p>
        <div id="noteURLStuff">
          <p>Here is your SneakyNote's secret link:</p>
          <p><span id="noteURL" class="highlightBox"></span></p>
          <p>
            Your link is valid for the next <span id="noteTimeRemaining">10 minutes</span> only.<br>
            It can only be accessed once.
          </p>
          <p>
            <a id="mailTo" class="button button-primary" href="mailto:?subject=A%20SneakyNote&body=I've%20encrypted%20a%20secret%20message%20for%20you%20using%20SneakyNote.com.%0D%0A%0D%0AVisit%20this%20link%20to%20see%20your%20message:%0D%0A%0D%0AURLHERE%0D%0A%0D%0AYou%20can%20only%20view%20the%20message%20once.%20The%20link%20will%20expire%20in%2010%20minutes.">Click here to email the link</a>
          </p>
          <p>Leave this page open until they read the note.</p>
          <p class="info">
            The link is selected and ready to copy if you<br>
            want to share it by something other than email.
          </p>
        </div>
        <div id="noteCodeStuff">
          <p>Your recipient has opened the note. Over the telephone, make sure they see this code:*</p>
          <p><span id="noteCode" class="highlightBox"></span></p>
          <p>If the codes match, then the note arrived safely.**</p>
          <p class="info">*Verify the code over the telephone or any channel unlikely to be vulnerable to a <a href="http://en.wikipedia.org/wiki/Man-in-the-middle_attack" target="_blank">man-in-the-middle attack</a>. Do not use the same communication method you used to send the secret link.</p>
          <p class="info">**If the codes do not match, then an attacker has intercepted your original note and sent along their own note instead. Immediately generate a new secret and send a <a href="/send">new SneakyNote</a> over a different channel.</p>
          <p class="thankYou">Thank you for trusting <a href="/">SneakyNote.com</a> to securely send your secret!</p>
        </div>
        <div id="noteExpiredStuff">
          <p>Your SneakyNote was not opened within 10 minutes. It is no longer available.</p>
          <p><a href="/send">Go back</a> and try sending your message again.</p>
        </div>
      </div>
    </div>
    <script>
      // Poor man's DOMContentLoaded...
      for (i in window.onReadyHandlers) {
        window.onReadyHandlers[i]();
      }
    </script>
    <script>
      function moveChaseBall() {
        var top  = Math.random() * byId("chaseBall").parentNode.clientHeight;
        var left = Math.random() * byId("chaseBall").parentNode.clientWidth;
        byId("chaseBall").style.top  = parseInt(top)  + "px";
        byId("chaseBall").style.left = parseInt(left) + "px";
      }

      // The SJCL default is 256 bits of randomness. We only need 160ish.
      // Most browsers have window.crypto, but prepare the progress bar for the few that don't.
      if (!sjcl.random.isReady()) {
        sjcl.random.startCollectors();
        moveChaseBall();
        byId("chaseBall").onmouseover = moveChaseBall;
        byId("chaseBall").onclick     = moveChaseBall;

        sjcl.random.addEventListener("progress", function(doneness) {
          var doneWidth = byId("randomnessProgress").clientWidth;
          byId("randomnessProgressBar").style.width = parseInt(doneness * doneWidth) + "px";
        });

        sjcl.random.addEventListener("seeded", function () {
          byId("randomnessProgress").style.display = "none";
          byId("chaseBall").style.display = "none";
        });
      } else {
        byId("randomnessProgress").style.display = "none";
        byId("chaseBall").style.display = "none";
      }
    </script>
  </body>
</html>
